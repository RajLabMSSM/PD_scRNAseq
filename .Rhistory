Cluster1_markers=row.names(clustB.uniqueMarkers))
write.csv(uniqueMarkers,
file.path(resultsPath,"unique_cluster_markers.csv"),
quote = F, row.names = F)
createDT(uniqueMarkers, "Unique/Mutually Exclusive Markers of Cluster 0 and Cluster 1")
return(uniqueMarkers)
}
uniqueMarkers <- identify_unique_markers(DAT, clusterA = 0, clusterA = 1, allGenes=allGenes)
uniqueMarkers <- identify_unique_markers(DAT, clusterA = 1, clusterA = 2, allGenes=allGenes)
uniqueMarkers <- identify_unique_markers(DAT, clusterA = 1, clusterB = 2, allGenes=allGenes)
#
if(getwd()=="/Users/schilder/Desktop/PD_scRNAseq"){
allGenes <- F
}else{allGenes <- T}
allGenes
uniqueMarkers <- identify_unique_markers(DAT, clusterA = 1, clusterB = 2, allGenes=allGenes)
uniqueMarkers <- identify_unique_markers(clustDAT, clusterA = 1, clusterB = 2, allGenes=allGenes)
clustDAT
identify_unique_markers <-function(DAT, clusterA, clusterB, allGenes=F){
DAT <- SetIdent(DAT, ident.use = "Cluster")
if(allGenes==F){
clustA.markers <- FindMarkers(DAT, ident.1=clusterA, min.pct = 0.25,
only.pos = F, test.use = "wilcox")
clustB.markers <- FindMarkers(DAT, ident.1=clusterB, min.pct = 0.25,
only.pos = F, test.use = "wilcox")
}else{
clustA.markers <- FindMarkers(DAT, ident.1=clusterA, min.pct = 0.25,
only.pos = F, test.use = "wilcox",
logfc.threshold = 0, min.pct = 0, min.cells.group = 1,
min.cells.gene = 1, min.diff.pct = -Inf)
clustB.markers <- FindMarkers(DAT, ident.1=clusterB, min.pct = 0.25,
only.pos = F, test.use = "wilcox",
logfc.threshold = 0, min.pct = 0, min.cells.group = 1,
min.cells.gene = 1, min.diff.pct = -Inf)
}
clustA.uniqueMarkers <- clustA.markers[!(row.names(clustA.markers) %in% row.names(clustB.markers)),] %>%
subset(p_val_adj<=0.05)
clustB.uniqueMarkers <- clustB.markers[!(row.names(clustB.markers) %in% row.names(clustA.markers)),] %>%
subset(p_val_adj<=0.05)
difference <- abs( length(row.names(clustA.uniqueMarkers)) - length(row.names(clustB.uniqueMarkers) ) )
uniqueMarkers <- data.frame(Cluster0_markers=c(row.names(clustA.uniqueMarkers), rep("",difference) ),
Cluster1_markers=row.names(clustB.uniqueMarkers))
write.csv(uniqueMarkers,
file.path(resultsPath,"unique_cluster_markers.csv"),
quote = F, row.names = F)
createDT(uniqueMarkers, "Unique/Mutually Exclusive Markers of Cluster 0 and Cluster 1")
return(uniqueMarkers)
}
uniqueMarkers <- identify_unique_markers(clustDAT, clusterA = 1, clusterB = 2, allGenes=allGenes)
DAT <- SetIdent(DAT, ident.use = "Cluster")
DAT
clusterA = 1
clusterB = 2
clusterA
clustA.markers <- FindMarkers(DAT, ident.1=clusterA, min.pct = 0.25,
only.pos = F, test.use = "wilcox")
DAT <- SetIdent(DAT, ident.use = "Cluster")
clustA.markers <- FindMarkers(DAT, ident.1=clusterA, min.pct = 0.25,
only.pos = F, test.use = "wilcox")
DAT@ident
DAT <- SetIdent(DAT, ident.use = Cluster)
DAT <- SetIdent(DAT, ident.use = DAT@meta.data$Cluster)
DAT@ident
clustA.markers <- FindMarkers(DAT, ident.1=clusterA, min.pct = 0.25,
only.pos = F, test.use = "wilcox")
identify_unique_markers <-function(DAT, clusterA, clusterB, allGenes=F){
DAT <- SetIdent(DAT, ident.use = DAT@meta.data$Cluster)
if(allGenes==F){
clustA.markers <- FindMarkers(DAT, ident.1=clusterA, min.pct = 0.25,
only.pos = F, test.use = "wilcox")
clustB.markers <- FindMarkers(DAT, ident.1=clusterB, min.pct = 0.25,
only.pos = F, test.use = "wilcox")
}else{
clustA.markers <- FindMarkers(DAT, ident.1=clusterA, min.pct = 0.25,
only.pos = F, test.use = "wilcox",
logfc.threshold = 0, min.pct = 0, min.cells.group = 1,
min.cells.gene = 1, min.diff.pct = -Inf)
clustB.markers <- FindMarkers(DAT, ident.1=clusterB, min.pct = 0.25,
only.pos = F, test.use = "wilcox",
logfc.threshold = 0, min.pct = 0, min.cells.group = 1,
min.cells.gene = 1, min.diff.pct = -Inf)
}
clustA.uniqueMarkers <- clustA.markers[!(row.names(clustA.markers) %in% row.names(clustB.markers)),] %>%
subset(p_val_adj<=0.05)
clustB.uniqueMarkers <- clustB.markers[!(row.names(clustB.markers) %in% row.names(clustA.markers)),] %>%
subset(p_val_adj<=0.05)
difference <- abs( length(row.names(clustA.uniqueMarkers)) - length(row.names(clustB.uniqueMarkers) ) )
uniqueMarkers <- data.frame(Cluster0_markers=c(row.names(clustA.uniqueMarkers), rep("",difference) ),
Cluster1_markers=row.names(clustB.uniqueMarkers))
write.csv(uniqueMarkers,
file.path(resultsPath,"unique_cluster_markers.csv"),
quote = F, row.names = F)
createDT(uniqueMarkers, "Unique/Mutually Exclusive Markers of Cluster 0 and Cluster 1")
return(uniqueMarkers)
}
geneList <- data.frame(Gene=row.names(DEGs_monocytes),
Weight=scales::rescale(length(DEGs_monocytes$p_val_adj):1))
geneList
enrichr_dbs <- c("KEGG_2018", "Reactome_2016",
"GO_Biological_Process_2018", "GO_Molecular_Function_2018", "GO_Cellular_Component_2018",
"Rare_Diseases_AutoRIF_ARCHS4_Predictions", "Human_Gene_Atlas")
# createDT(enrichR::listEnrichrDbs(), "Enrichr Databases")
geneList <- data.frame(Gene=row.names(DEGs_monocytes),
Weight=scales::rescale(length(DEGs_monocytes$p_val_adj):1))
results <- enrichr(genes = geneList, databases = enrichr_dbs )
for (db in enrichr_dbs){
cat('\n')
cat("##",db,"\n")
# res <- subset(results[[db]], Adjusted.P.value<=0.05)
createDT_html(results[[db]], paste("Enrichr Results:",db))
cat('\n')
}
overlappingGenes_PD
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA"), cell_size = 0.8)
# Monocle plot
plot_cell_clusters(mDAT, markers = overlappingGenes_AD, cell_size = 0.8)
overlappingGenes_AD <- enrichment_test_and_plots(clustDAT, DEGs_monocytes_sig, ADgenes$Gene)
overlappingGenes_AD
overlappingGenes_AD <- enrichment_test_and_plots(clustDAT, DEGs_monocytes_sig, ADgenes$Gene)
clustDAT <- SubsetData(DAT, subset.name = "Cluster", accept.value = c(1,2), do.scale = F)
# PLOT FUNCTIONS
overlap_heatmap <- function(clustDAT, geneList, title="Overlapping Genes:\nGene List vs. DGE Genes"){
markerDF  <- get_markerDT(clustDAT, markerList = geneList, rawData = T)
markerMatrix <- reshape2::acast(markerDF, Gene~post_clustering, value.var="Expression",
fun.aggregate = mean, drop = F, fill = 0)
# Heatmap.2
my_palette <- colorRampPalette(c("purple", "black", "cyan"))(n = 1000)
hmap <- gplots::heatmap.2(markerMatrix, xlab = "Cluster", dendrogram = "row",
col = my_palette, tracecol = "gray", srtCol = 0, offsetCol=1.5, vline=T,
trace='none', key.title=NA, key.ylab = "Expression", colsep=T, sepwidth = 0.01,
main = title)
}
make_fractionDF <- function(DEGs_monocytes_sig, geneList, allGenes=F){
DEGs_monocytes_sig$Gene <- row.names(DEGs_monocytes_sig)
if(allGenes==F){
geneDF <- subset(DEGs_monocytes_sig, Gene%in%geneList)
} else{geneDF <- DEGs_monocytes_sig}
pct_df <- melt(geneDF, id.vars = c("Gene","avg_logFC"), measure.vars = c("pct.2", "pct.1"),
variable.name = "Cluster", value.name = "FractionCells")
pct_df$Cluster <- ifelse(pct_df$Cluster=="pct.1", "2", "1")
return(pct_df)
}
cellFractions_plot <- function (DEGs_monocytes_sig, geneList, title="", allGenes=F){
pct_df <- make_fractionDF(DEGs_monocytes_sig, geneList, allGenes)
# Fraction Cells
cfp <- ggplot(data=pct_df, aes(x=Gene, y=FractionCells, fill=Cluster)) + geom_col(position="dodge") +
labs(title = title, y="Fraction of Cells", x="Gene") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
if(allGenes==T){
cfp <- cfp +  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8))
print(ggplotly(cfp))
}else{print(cfp)}
}
logFC_plot <- function(DEGs_monocytes_sig, geneList, title="", allGenes=F){
pct_df <- make_fractionDF(DEGs_monocytes_sig, geneList, allGenes)
# LogFC
lfcp <- ggplot(data=pct_df, aes(x=Gene, y=avg_logFC, fill=Gene)) + geom_col(position="dodge") +
theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
labs(title = title, y="avg_logFC", x="Gene")
if(allGenes==T){
lfcp <- lfcp +  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8))
print(ggplotly(lfcp))
}else{print(lfcp)}
}
enrichment_test_and_plots <- function(DAT, DEG_df, geneList, disease=""){
overlappingGenes <- report_overlap(clustDAT,
list1=row.names(DEG_df),
list2=geneList)
## All DEGs
# cellFractions_plot(DEG_df, geneList,
#                      title= paste("Fraction of Cells Expressing\nAll",disease,"Genes"), allGenes = T)
# logFC_plot(DEG_df, geneList,  title= "LogFC\nAll PD Genes", allGenes = T)
# Overlapping Genes
if(length(overlappingGenes)>0){
# FeaturePlot(DAT, features.plot = overlappingGenes, dark.theme = T)
cellFractions_plot(DEG_df, overlappingGenes,
title= paste("Fraction of Cells Expressing\n",disease,"Genes Overlapping with DEGs") )
logFC_plot(DEG_df, overlappingGenes, title= paste("LogFC\n",disease,"Genes Overlapping with DEGs") )
if(length(overlappingGenes)>1){
overlap_heatmap(clustDAT, geneList=overlappingGenes,
title=paste("Overlapping Genes:\n",disease,"Genes vs. DGE Genes") )
}
} else {cat("There were no overlapping genes between the DGE list and",disease,"genes.")}
return(overlappingGenes)
}
purpleScale <-  c("grey","purple","blueviolet","magenta")
heatScale <-  c("yellow","grey","red")
overlappingGenes_PD <- enrichment_test_and_plots(clustDAT, DEGs_monocytes_sig, PDgenes$Gene)
# Moncle plot
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA", overlappingGenes_PD), cell_size = 0.8)
overlappingGenes_AD <- enrichment_test_and_plots(clustDAT, DEGs_monocytes_sig, ADgenes$Gene)
DEGs_monocytes_sig
test_hyperparameters(mDAT, iter_var="resolution")
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
# load(file.path(resultsPath, "scRNAseq_results.RData"))
# resultsPath <- "Results/subsetGenes-protein_coding__subsetCells-F__Resolution-0.2__perplexity-40__nCores-4"
# load(file.path(resultsPath,"scRNAseq_results.RData"))
library(Seurat)
library(cowplot)
library(ggplot2)
library(dplyr)
library(data.table)
library(readxl)
library(reshape2)
library(ggrepel)
library(plotly)
library(GeneOverlap) # BiocManager::install("GeneOverlap")
library(enrichR) #BiocManager::install("enrichR")
## Upgrade to alpha (development) version of Monocle, as this version has been optimized for large datasets
if("DDRTree" %in% rownames(installed.packages())==F){
devtools::install_github("cole-trapnell-lab/DDRTree", ref="simple-ppt-like")
}
if("graph" %in% rownames(installed.packages())==F){
devtools::install_github("cole-trapnell-lab/L1-graph")
}
if("reticulate" %in% rownames(installed.packages())==F){
install.packages("reticulate")
}
if("flexclust" %in% rownames(installed.packages())==F){
install.packages("flexclust")
}
if("mcclust" %in% rownames(installed.packages())==F){
install.packages("mcclust")
}
library(flexclust)
library(mcclust)
library(reticulate)
if(py_module_available("umap-learn")==F){
reticulate::py_install('umap-learn')# , pip = T, pip_ignore_installed = T # Ensure the latest version of UMAP is installed
}
if(py_module_available("louvain")==F){
reticulate::py_install("louvain")
system("pip install louvain --user")
}
if("monocle" %in% rownames(installed.packages())==F){
devtools::install_github("cole-trapnell-lab/monocle-release", ref="monocle3_alpha")
}
if("ggrastr" %in% rownames(installed.packages())==F){
devtools::install_github("VPetukhov/ggrastr")
}
library(monocle) # BiocManager::install("monocle")
# BiocManager::install(c('DelayedArray', 'DelayedMatrixStats', 'org.Hs.eg.db', 'org.Mm.eg.db'))
library(org.Hs.eg.db)
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
#
if(getwd()=="/Users/schilder/Desktop/PD_scRNAseq"){
allGenes <- F
}else{allGenes <- T}
allGenes
sessioninfo::session_info()
# Import Seurat obj
load(file.path(root, "Data/seurat_object_add_HTO_ids.Rdata"))
DAT <- seurat.obj
rm(seurat.obj)
# Add metadata
metadata <- read.table(file.path(root,"Data/meta.data4.tsv"))
DAT <- AddMetaData(object = DAT, metadata = metadata)
protDAT <- subsetBiotypes(DAT, subsetGenes = "protein_coding")
protDAT <- remove_nonmatched_metadata(protDAT, subsetCells = F)
protDAT <- FindVariableGenes(object = protDAT, mean.function = ExpMean,
dispersion.function = LogVMR,
selection.method ="dispersion", do.plot = T,
top.genes = 2000)
# Pass TRUE if you want to see progress output on some of Monocle 3's operations
DelayedArray:::set_verbose_block_processing(TRUE)
# Passing a higher value will make some computations faster but use more memory. Adjust with caution!
options(DelayedArray.block.size=1000e6)
## Construct CDS object manually
# mDAT <- newCellDataSet(cellData = DAT@scale.data,
#                        featureData = AnnotatedDataFrame( data.frame(gene_short_name=row.names(DAT@scale.data),
#                                                                     row.names = row.names(DAT@scale.data))
#                          ),
#                        phenoData = AnnotatedDataFrame(DAT@meta.data))
# mDAT <- estimateSizeFactors(mDAT) #DESeq2?
# mDAT <- preprocessCDS(mDAT, method = "PCA", num_dim = 10, norm_method = "none")
## Construct CDS object automaticaly
### NOTE!: importCDS takes only the raw.data (not scale.data)
mDAT <- monocle::importCDS(protDAT,  import_all = T)
mDAT <- estimateSizeFactors(mDAT) #DESeq2?
mDAT <- estimateDispersions(mDAT)
# Regressing out ID will also regress out mutation status
mDAT <- preprocessCDS(mDAT, num_dim = 20, residualModelFormulaStr = "~ nUMI + percent.mito")
# !Important! (allows replicability)
set.seed(1) # Monocle sets their seed to 2016 by default (Seurat sets it to 1)
# Options: c("UMAP", "tSNE", "DDRTree", "ICA", "none")
## UMAP
# monocle:::UMAP( )
mDAT <- reduceDimension(mDAT, reduction_method = 'UMAP',
max_components = 3,
metric="cosine",
n_threads =  parallel::detectCores())
## t-SNE
# mDAT <- reduceDimension(mDAT, reduction_method = 'tSNE',
#                         perplexity = 30,
#                         scaling = F,
#                         num_threads = parallel::detectCores())
pretty_colors <- function(mDAT, var="Cluster", palette="custom"){
unique_var <- unique(as.character(pData(mDAT)[var][,1]))
if(palette=="custom"){
col_vector_origin <- c("mediumorchid","deepskyblue","limegreen","steelblue",
"hotpink","turquoise", "blueviolet","mediumvioletred",
"#db83da","#53c35d","#a546bb","#718fe8","#a469e6",
"#babb3d","#4f66dc","#e68821","#83b837","#d6ac3e",
"#7957b4","#468e36","#d347ae","#5dbf8c","#e53e76",
"#42c9b8","#dd454a","#3bbac6","#d5542c","#59aadc",
"#cf8b36","#4a61b0","#8b8927","#a24e99","#9cb36a",
"#ca3e87","#36815b","#b23c4e","#5c702c","#b79add",
"#a55620","#5076af","#e38f67","#85609c","#caa569",
"#9b466c","#88692c","#dd81a9","#a35545","#e08083",
"#17becf","#9edae5")
} else{col_vector_origin <- RColorBrewer::brewer.pal(length(unique_var),palette)}
# barplot(1:length(col_vector_origin) , col=col_vector_origin)
col_vector <- col_vector_origin[1:length(unique_var)]
names(col_vector) <- unique_var
return(col_vector)
}
plotDR <- function(resDAT, metavar="Cluster", title=""){
options(repr.plot.width = 11)
options(repr.plot.height = 8)
col_vector <- pretty_colors(resDAT, var=metavar)
p <- plot_cell_clusters(resDAT,
color_by = metavar,
cell_size = 0.8,
show_group_id = T)  +
scale_color_manual(values = col_vector) +
theme(legend.text=element_text(size=6)) +
theme(legend.position="right")+
labs(title = paste(title))
print(p)
}
test_hyperparameters <- function(mDAT, resolutions=seq(0, 1e-4,length.out=6),
Ks=seq(10,60,length.out=6),
iter_var="k"){
if(iter_var=="resolution"){
for(res in resolutions){
res_title <- paste("Resolution =",res)
cat("\n")
cat("####",res_title,"\n")
try({
resDAT <- clusterCells(mDAT, res=res,# k=43,
method = "louvain",# densityPeak
louvain_iter = 1,
verbose = F,
clustering_genes = clustering_genes,
cores = parallel::detectCores())
plotDR(resDAT, title=res_title)
})
cat("\n")
}
}else{
for(k in Ks){
k_title <- paste("K =",k)
cat("\n")
cat("###",k_title,"\n")
try({
kDAT <- clusterCells(mDAT, res=8.888889e-05, k=k,
method = "louvain",# densityPeak
louvain_iter = 1,
verbose = F,
clustering_genes = clustering_genes,
cores = parallel::detectCores())
plotDR(kDAT, title=k_title)
})
cat("\n")
}
}
}
test_hyperparameters(mDAT, iter_var="resolution")
# test_hyperparameters(mDAT, iter_var="k")
# Select final resolution
## Use ONLY the 1000 most variable genes to do clustering (otherwise there's too much noise)
clustering_genes <- intersect(mDAT@featureData@data$gene_short_name, protDAT@var.genes)[1:1000]
louvain_res <- 1e-04 # 1e-04 is the default
mDAT <- clusterCells(mDAT, res=louvain_res,
method = "louvain",
louvain_iter = 1,
clustering_genes = clustering_genes,
verbose = T, cores = parallel::detectCores())
# mDAT <- clusterCells(mDAT, num_clusters = 4,
#                         method = "densityPeak",
#                         verbose = F,
#                         cores = parallel::detectCores())
plotDR(mDAT, "Cluster")
plotDR(mDAT, "dx")
plotDR(mDAT, "mut")
# CLUSTERING FROM SEURAT
# plotDR(mDAT, "post_clustering")
plotDR <- function(resDAT, metavar="Cluster", title=""){
# options(repr.plot.width = 11)
# options(repr.plot.height = 8)
col_vector <- pretty_colors(resDAT, var=metavar)
p <- plot_cell_clusters(resDAT,
color_by = metavar,
cell_size = 0.8,
show_group_id = T)  +
scale_color_manual(values = col_vector) +
theme(legend.text=element_text(size=6)) +
theme(legend.position="right")+
labs(title = paste(title))
print(p)
}
plotDR(mDAT, "dx")
# mDAT <- clusterCells(mDAT, num_clusters = 4,
#                         method = "densityPeak",
#                         verbose = F,
#                         cores = parallel::detectCores())
plotDR(mDAT, "Cluster")
# options(repr.plot.width = 11)
# options(repr.plot.height = 8)
col_vector <- pretty_colors(resDAT, var=metavar)
plot_cell_clusters(mDAT, color_by = "dx")
plot_cell_clusters(mDAT, color_by = "mut")
plot_cell_clusters(mDAT, color_by = "mut", cell_size = .8)
# generate size factors for normalization later
# Get pre-trained PBMC classifer
load(file.path(root, "Data/Garnett/hsPBMC")) # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
mDAT <- garnett::classify_cells(mDAT,
classifier = hsPBMC,
db = org.Hs.eg.db,
cluster_extend = TRUE,
cds_gene_id_type = "SYMBOL")
table(pData(mDAT)$cell_type)
cell_summary <- table(pData(mDAT)$cluster_ext_type)
cell_summary
# Get feature genes for each cell type
feature_genes <- garnett::get_feature_genes(classifier = hsPBMC,
node = "root",
db = org.Hs.eg.db,
convert_ids = F)
head(feature_genes)
# If a cell type is called less than n times, re-categorize it as unknown
mDAT$cluster_ext_type_filt <- ifelse(mDAT$cluster_ext_type %in% names(cell_summary[cell_summary<50]),
"Unknown", mDAT$cluster_ext_type)
plot_cell_clusters(mDAT, color_by ="cell_type", cell_size = .8) +  facet_wrap(~dx)
plot_cell_clusters(mDAT, color_by ="cluster_ext_type", cell_size = .8)
plot_cell_clusters(mDAT, color_by ="cluster_ext_type_filt", cell_size = .8)
plot_cell_clusters(mDAT, markers = c("CD14","FCGR3A"), cell_size = 0.8)
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA"), cell_size = 0.8)
plot_cell_clusters(mDAT, markers = c("MS4A4A","MS4A6A"), cell_size = 0.8)
plot_markers_cluster(mDAT, markers = protDAT@var.genes[1:50], minimal_cluster_fraction = 0.05)
# subsetCDS(mDAT, )
mDAT <- partitionCells(mDAT)
mDAT <- learnGraph(mDAT, RGE_method = 'SimplePPT',
n_threads =  parallel::detectCores())
plot_cell_trajectory(mDAT, color_by = "Cluster", cell_size = .01)
plot_cell_trajectory(mDAT, color_by = "dx", cell_size = .01)
plot_cell_trajectory(mDAT, color_by = "mut", cell_size = .01)
plot_cell_trajectory(mDAT, color_by = "cluster_ext_type_filt", cell_size = .01)
# dir.create(file.path(resultsPath, "pseudotime"), showWarnings = F)
# plot_3d_cell_trajectory(mDAT,
#                         color_by="cell_type",
#                         webGL_filename= file.path(resultsPath, "pseudotime/pseudotime_cellType.html"),
#                         show_backbone=TRUE,
#                         useNULL_GLdev=TRUE)
# plot_3d_cell_trajectory(mDAT, markers = c('FCGR3A'),
#                         webGL_filename=file.path(resultsPath, "pseudotime/pseudotime_FCGR3A.html"),
#                         show_backbone=TRUE,
#                         useNULL_GLdev=TRUE)
save.image(file.path(resultsPath, "scRNAseq_results.RData"))
load(file.path(resultsPath, "scRNAseq_results.RData"))
DEGs
x <- read_excel("../Differential Gene Expression.xlsx")
head(x)
DEGs <- read_excel("../Differential Gene Expression.xlsx", skip = 1 )
head(DEGs)
DEGs <- read_excel("../Differential Gene Expression.xlsx", skip = 2 )
head(DEGs)
# convert 0 to the smallest number R can represent(2.225074e-308)
DEGs[DEGs$p_val==0.0000000000000000000000000000,"p_val"] <- 2.225074e-308
DEGs[DEGs$p_val==2.225074e-308,"p_val"] <-   "Fuzzy Lumpkins"
head(DEGs)
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
load(file.path(resultsPath, "scRNAseq_results.RData"))
# resultsPath <- "Results/subsetGenes-protein_coding__subsetCells-F__Resolution-0.2__perplexity-40__nCores-4"
library(Seurat)
library(cowplot)
library(ggplot2)
library(dplyr)
library(data.table)
library(readxl)
library(reshape2)
library(ggrepel)
library(plotly)
library(GeneOverlap) # BiocManager::install("GeneOverlap")
library(enrichR) #BiocManager::install("enrichR")
library(monocle) # BiocManager::install("monocle")
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
#
if(getwd()=="/Users/schilder/Desktop/PD_scRNAseq"){
allGenes <- F
}else{allGenes <- T}
allGenes
# session_info() #Doesn't work on Minerva?
ADgenes
if(allClusts==T){ clusterList <- unique(DAT@meta.data$Cluster) }
allClusts=F
allClusts=T
if(allClusts==T){ clusterList <- unique(DAT@meta.data$Cluster) }
clusterList
unique(DAT@meta.data$Cluster)
DEGs
DEGs <- replace_zero_pvals(DEGs)
DEGs$gene <- row.names(DEGs)
DEGs
row.names(DEGs)
DEGs
