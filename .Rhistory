method = "louvain",
verbose = T, cores = parallel::detectCores())
library(louvain)
library(monocle) # BiocManager::install("monocle")
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = T, cores = parallel::detectCores())
resDAT <- clusterCells(mDAT,
method = "louvain",
verbose = T, cores = parallel::detectCores())
resDAT <- clusterCells(mDAT, res=0.001,
method = "louvain",
verbose = T, cores = parallel::detectCores())
mDAT <- clusterCells(mDAT,
method = "densityPeak",
verbose = T, cores = parallel::detectCores())
plotDR(mDAT)
reticulate::py_install("louvain")
library(reticulate)
resDAT <- clusterCells(mDAT,
method = "louvain",
verbose = T, cores = parallel::detectCores(), python_home="")
resDAT <- clusterCells(mDAT, res=0.001,
method = "louvain",
verbose = T, cores = parallel::detectCores(), python_home="")
resDAT <- clusterCells(mDAT, res=0.001,
method = "louvain",
verbose = T, cores = parallel::detectCores())
library(igraph)
resDAT <- clusterCells(mDAT, res=0.001,
method = "louvain",
verbose = T, cores = parallel::detectCores(), python_home="")
resDAT <- clusterCells(mDAT, res=0.001,
method = "louvain",
verbose = T, cores = parallel::detectCores())
reticulate::py_install("louvain")
reticulate::py_module_available("louvain")
resDAT <- clusterCells(mDAT, res=0.001,
method = "louvain",
verbose = T, cores = parallel::detectCores())
plotDR(resDAT)
test_resolutions <- function(mDAT, resolutions=seq(0, 1e-4, length.out = 5)){
for(res in resolutions){
cat("Resolution = ",res)
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = T, cores = parallel::detectCores())
plotDR(resDAT)
}
}
test_resolutions(mDAT)
plotDR <- function(mDAT, title=""){
col_vector <- col_vector_origin[1:length(unique(as.character(pData(mDAT)$dx)))]
names(col_vector) <- unique(as.character(pData(mDAT)$dx))
p <- plot_cell_clusters(mDAT,
color_by = 'Cluster',
cell_size = 0.5,
show_group_id = T)  +
theme(legend.text=element_text(size=6)) +
theme(legend.position="right")+
labs(title = paste(title))
print(p)
}
plotDR(resDAT, title=res_title)
res_title <- paste("Resolution =",res)
res=0
res_title <- paste("Resolution =",res)
plotDR(resDAT, title=res_title)
test_resolutions <- function(mDAT, resolutions=seq(0, 1e-4, length.out = 10)){
for(res in resolutions){
res_title <- paste("Resolution =",res)
cat("\n",res_title,"\n")
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = T, cores = parallel::detectCores())
plotDR(resDAT, title=res_title)
}
}
test_resolutions(mDAT)
mDAT <- reduceDimension(mDAT, reduction_method = 'UMAP')
test_resolutions(mDAT)
plotDR <- function(mDAT, title="", metavar="Cluster"){
col_vector <- col_vector_origin[1:length(unique(as.character(pData(mDAT)$dx)))]
names(col_vector) <- unique(as.character(pData(mDAT)$dx))
p <- plot_cell_clusters(mDAT,
color_by = metavar,
cell_size = 0.5,
show_group_id = T)  +
theme(legend.text=element_text(size=6)) +
theme(legend.position="right")+
labs(title = paste(title))
print(p)
}
plotDR <- function(mDAT, metavar="Cluster", title=""){
col_vector <- col_vector_origin[1:length(unique(as.character(pData(mDAT)$dx)))]
names(col_vector) <- unique(as.character(pData(mDAT)$dx))
p <- plot_cell_clusters(mDAT,
color_by = metavar,
cell_size = 0.5,
show_group_id = T)  +
theme(legend.text=element_text(size=6)) +
theme(legend.position="right")+
labs(title = paste(title))
print(p)
}
plotDR(mDAT, "Cluster")
plotDR(mDAT, "dx")
plotDR(mDAT, "cell_type")
# generate size factors for normalization later
# Get pre-trained PBMC classifer
load(file.path(root, "Data/Garnett/hsPBMC")) # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
mDAT <- garnett::classify_cells(mDAT,
classifier = hsPBMC,
db = org.Hs.eg.db,
cluster_extend = TRUE,
cds_gene_id_type = "SYMBOL")
table(pData(mDAT)$cell_type)
table(pData(mDAT)$cluster_ext_type)
# Get feature genes for each cell type
feature_genes <- garnett::get_feature_genes(classifier = hsPBMC,
node = "root",
db = org.Hs.eg.db,
convert_ids = F)
head(feature_genes)
mDAT <- garnett::classify_cells(mDAT,
classifier = hsPBMC,
db = org.Hs.eg.db,
# cluster_extend = TRUE,
cds_gene_id_type = "SYMBOL")
table(pData(mDAT)$cell_type)
# Get feature genes for each cell type
feature_genes <- garnett::get_feature_genes(classifier = hsPBMC,
node = "root",
db = org.Hs.eg.db,
convert_ids = F)
head(feature_genes)
plotDR(mDAT, metavar = "cell_type")
plotDR(mDAT, "mut")
plot_cell_clusters(mDAT, markers = "CD14")
plot_cell_clusters(mDAT, markers = c("CD14","FCGR3A"))
plot_cell_clusters(mDAT, markers = c("CD14","FCGR3A"), cell_size = 0.5)
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA"), cell_size = 0.5)
plot_cell_clusters(mDAT, markers = c("CD14","FCGR3A"), cell_size = 0.5)
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA"), cell_size = 0.5)
# Combine AD gene lists
curatedGenes <- read_excel("Data/curated_AD-PDgene_lists.xlsx")
AD_related_genes <- read_excel(file.path(root, "Data/AD-related_genes.xlsx"))
ADgenes <- rbind(AD_related_genes, data.frame(Gene=curatedGenes$AD_panel, Category="AD") ) %>% unique()
# Combine PD gene lists
PDgenes <- data.frame(Gene=c("LRRK2","GBA",
curatedGenes$gwas_Nearest_gene_Nalls_2019,
curatedGenes$QTL_Nominated_genes_Nalls_2019,
curatedGenes$TWAS_Garrett
), Category="PD") %>% unique()
MonocyteSubtype.markers <- read.csv(file.path(root, resultsPath, "MonocyteSubtype.markers.csv"), row.names = 1)
MonocyteSubtype.markers_sig <- subset(MonocyteSubtype.markers, p_val_adj <= 0.05)
createDT(MonocyteSubtype.markers, "Full list of DEGs: Cluster 0 vs. Cluster 1")
report_overlap <- function(DAT, list1, list2){
genomeSize <- dim(DAT@raw.data)[1]
go.obj <- newGeneOverlap(listA = list1, listB = list2, genome.size = genomeSize )
go.obj <- testGeneOverlap(go.obj)
print(go.obj)
overlappingGenes <- getIntersection(go.obj)
percent_of_targetGenes <- length(overlappingGenes) / length(list2)*100
percent_of_DEGs <- length(overlappingGenes) / length(list1)*100
targetGenes_DEGs <- list2[overlappingGenes %in% list2]
cat("\n",round(percent_of_targetGenes, 2),"% of the provided genes (",length(overlappingGenes),"/",length(list2),") are differentially expressed between Canonical vs. Intermediate monocyte subtypes.")
cat("\n",round(percent_of_DEGs, 2),"% of the DEGs between Canonical vs. Intermediate  monocyte subtypes (",
length(overlappingGenes),"/",length(list1),") are in the provided gene list.")
cat("\n-------------------------------------------------------",
"\n\n********** Enrichment p-value =",go.obj@pval,"**********\n\n")
return(overlappingGenes)
}
# PLOT FUNCTIONS
overlap_heatmap <- function(clustDAT, geneList, title="Overlapping Genes:\nGene List vs. DGE Genes"){
markerDF  <- get_markerDT(clustDAT, markerList = geneList, rawData = T)
markerMatrix <- reshape2::acast(markerDF, Gene~post_clustering, value.var="Expression",
fun.aggregate = mean, drop = F, fill = 0)
# Heatmap.2
my_palette <- colorRampPalette(c("purple", "black", "cyan"))(n = 1000)
hmap <- gplots::heatmap.2(markerMatrix, xlab = "Cluster", dendrogram = "row",
col = my_palette, tracecol = "gray", srtCol = 0, offsetCol=1.5, vline=T,
trace='none', key.title=NA, key.ylab = "Expression", colsep=T, sepwidth = 0.01,
main = title)
}
make_fractionDF <- function (MonocyteSubtype.markers_sig, geneList, allGenes=F){
MonocyteSubtype.markers_sig$Gene <- row.names(MonocyteSubtype.markers_sig)
if(allGenes==F){
geneDF <- subset(MonocyteSubtype.markers_sig, Gene%in%geneList)
} else{geneDF <- MonocyteSubtype.markers_sig}
pct_df <- melt(geneDF, id.vars = c("Gene","avg_logFC"), measure.vars = c("pct.2", "pct.1"),
variable.name = "Cluster", value.name = "FractionCells")
pct_df$Cluster <- ifelse(pct_df$Cluster=="pct.1", "1", "0")
return(pct_df)
}
cellFractions_plot <- function (MonocyteSubtype.markers_sig, geneList, title="", allGenes=F){
pct_df <- make_fractionDF(MonocyteSubtype.markers_sig, geneList, allGenes)
# Fraction Cells
cfp <- ggplot(data=pct_df, aes(x=Gene, y=FractionCells, fill=Cluster)) + geom_col(position="dodge") +
labs(title = title, y="Fraction of Cells", x="Gene") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
if(allGenes==T){
cfp <- cfp +  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8))
print(ggplotly(cfp))
}else{print(cfp)}
}
logFC_plot <- function(MonocyteSubtype.markers_sig, geneList, title="", allGenes=F){
pct_df <- make_fractionDF(MonocyteSubtype.markers_sig, geneList, allGenes)
# LogFC
lfcp <- ggplot(data=pct_df, aes(x=Gene, y=avg_logFC, fill=Gene)) + geom_col(position="dodge") +
theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none") +
labs(title = title, y="avg_logFC", x="Gene")
if(allGenes==T){
lfcp <- lfcp +  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8))
print(ggplotly(lfcp))
}else{print(lfcp)}
}
enrichment_test_and_plots <- function(DAT, DEG_df, geneList, disease=""){
overlappingGenes <- report_overlap(clustDAT,
list1=row.names(DEG_df),
list2=geneList)
## All DEGs
# cellFractions_plot(DEG_df, geneList,
#                      title= paste("Fraction of Cells Expressing\nAll",disease,"Genes"), allGenes = T)
# logFC_plot(DEG_df, geneList,  title= "LogFC\nAll PD Genes", allGenes = T)
# Overlapping Genes
if(length(overlappingGenes)>0){
FeaturePlot(DAT, features.plot = overlappingGenes, dark.theme = T)
cellFractions_plot(DEG_df, overlappingGenes,
title= paste("Fraction of Cells Expressing\n",disease,"Genes Overlapping with DEGs") )
logFC_plot(DEG_df, overlappingGenes, title= paste("LogFC\n",disease,"Genes Overlapping with DEGs") )
if(length(overlappingGenes)>1){
overlap_heatmap(clustDAT, geneList=overlappingGenes,
title=paste("Overlapping Genes:\n",disease,"Genes vs. DGE Genes") )
}
} else {cat("There were no overlapping genes between the DGE list and",disease,"genes.")}
return(overlappingGenes)
}
purpleScale <-  c("grey","purple","blueviolet","magenta")
heatScale <-  c("yellow","grey","red")
overlappingGenes_PD <- enrichment_test_and_plots(clustDAT, MonocyteSubtype.markers_sig, PDgenes$Gene)
overlappingGenes_PD <- enrichment_test_and_plots(clustDAT, MonocyteSubtype.markers_sig, ADgenes$Gene)
overlappingGenes_AD <- enrichment_test_and_plots(clustDAT, MonocyteSubtype.markers_sig, ADgenes$Gene)
overlappingGenes_AD
overlappingGenes_AD <- enrichment_test_and_plots(clustDAT, MonocyteSubtype.markers_sig, ADgenes$Gene)
overlappingGenes_PD <- enrichment_test_and_plots(clustDAT, MonocyteSubtype.markers_sig, PDgenes$Gene)
plot_cell_clusters(mDAT, markers = overlappingGenes_AD, cell_size = 0.5)
plot_cell_clusters(mDAT, markers = overlappingGenes_AD, cell_size = 0.5)
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA", overlappingGenes_PD), cell_size = 0.5)
plot_cell_clusters(mDAT, markers = c("MS4A4A","MS4A6A"), cell_size = 0.5)
plotDR(mDAT, "dx")
plotDR(mDAT, c("dx","mut"))
plot_cell_clusters(mDAT,
color_by = c("dx","mut"),
cell_size = 0.5,
show_group_id = T)
plot_grid(ncol = 2,
plotDR(mDAT, "dx"),
plotDR(mDAT, "mut")
)
plot_cell_clusters(mDAT, markers = c("MS4A4A","MS4A6A"), cell_size = 0.5, nrow = 1, ncol = 1)
test_resolutions <- function(mDAT, resolutions=seq(0, 1e-4, length.out = 10)){
for(res in resolutions){
res_title <- paste("Resolution =",res)
cat("\n",res_title,"\n")
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = F, cores = parallel::detectCores())
plotDR(resDAT, title=res_title)
}
}
# monocle:::UMAP()
monocle::plot_cell_fdl(mDAT)
# monocle:::UMAP()
monocle::plot_cell_fdl(cds=mDAT)
# monocle:::UMAP()
monocle::plot_cell_fdl(cds=mDAT, color_by = "cell_type")
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA", overlappingGenes_PD), cell_size = 0.5) + facet_wrap(~dx)
plotDR(mDAT, metavar = "cell_type") +
facet_wrap(~dx)
mDAT <- reduceDimension(mDAT, reduction_method = 'tSNE', perplexity = 40, num_threads = parallel::detectCores())
plotDR(mDAT, "dx")
plotDR(mDAT, "mut")
# clustDAT <- SubsetData(DAT, subset.name = "post_clustering", accept.value = c(0,1), do.scale = F)
# subDAT <- SubsetData(clustDAT, cells.use = c(1:50, (dim(clustDAT@data)[2]-49):dim(clustDAT@data)[2]) )
# Pass TRUE if you want to see progress output on some of Monocle 3's operations
DelayedArray:::set_verbose_block_processing(TRUE)
# Passing a higher value will make some computations faster but use more memory. Adjust with caution!
options(DelayedArray.block.size=1000e6)
mDAT <- monocle::importCDS(DAT,  import_all = T)
mDAT <- estimateSizeFactors(mDAT) #DESeq2?
# mDAT <- estimateDispersions(mDAT)
mDAT <- preprocessCDS(mDAT, num_dim = 20)
# Dimensionality Reduction
# Options: c("UMAP", "tSNE", "DDRTree", "ICA", "none")
# mDAT <- reduceDimension(mDAT, reduction_method = 'UMAP')
set.seed(1) # Monocle sets their seed to 2016 by default (Seurat sets it to 1)
mDAT <- reduceDimension(mDAT, reduction_method = 'tSNE',
perplexity = 40,
num_threads = parallel::detectCores())
# monocle:::UMAP()
col_vector_origin <- c("#db83da",
"#53c35d",
"#a546bb",
"#83b837",
"#a469e6",
"#babb3d",
"#4f66dc",
"#e68821",
"#718fe8",
"#d6ac3e",
"#7957b4",
"#468e36",
"#d347ae",
"#5dbf8c",
"#e53e76",
"#42c9b8",
"#dd454a",
"#3bbac6",
"#d5542c",
"#59aadc",
"#cf8b36",
"#4a61b0",
"#8b8927",
"#a24e99",
"#9cb36a",
"#ca3e87",
"#36815b",
"#b23c4e",
"#5c702c",
"#b79add",
"#a55620",
"#5076af",
"#e38f67",
"#85609c",
"#caa569",
"#9b466c",
"#88692c",
"#dd81a9",
"#a35545",
"#e08083",
"#17becf",
"#9edae5")
plotDR <- function(mDAT, metavar="Cluster", title=""){
col_vector <- col_vector_origin[1:length(unique(as.character(pData(mDAT)$dx)))]
names(col_vector) <- unique(as.character(pData(mDAT)$dx))
p <- plot_cell_clusters(mDAT,
color_by = metavar,
cell_size = 0.5,
show_group_id = T)  +
theme(legend.text=element_text(size=6)) +
theme(legend.position="right")+
labs(title = paste(title))
print(p)
}
plotDR(mDAT, "dx")
plotDR(mDAT, "mut")
mDAT <- reduceDimension(mDAT, reduction_method = 'UMAP', n_threads =  parallel::detectCores())
plotDR(mDAT, "dx")
mDAT@dim_reduce_type
mDAT@reducedDimS
# NOTE!: importCDS takes only the raw.data (not scale.data)
mDAT <- monocle::importCDS(DAT,  import_all = T)
mDAT <- estimateSizeFactors(mDAT) #DESeq2?
# Pass TRUE if you want to see progress output on some of Monocle 3's operations
DelayedArray:::set_verbose_block_processing(TRUE)
# Passing a higher value will make some computations faster but use more memory. Adjust with caution!
options(DelayedArray.block.size=1000e6)
# mDAT <- estimateDispersions(mDAT)
mDAT <- preprocessCDS(mDAT, num_dim = 20, residualModelFormulaStr = c("nUMI", "percent.mito"))
# mDAT <- estimateDispersions(mDAT)
mDAT <- preprocessCDS(mDAT, num_dim = 20, residualModelFormulaStr = "~ nUMI", "percent.mito")
# mDAT <- estimateDispersions(mDAT)
mDAT <- preprocessCDS(mDAT, num_dim = 20, residualModelFormulaStr = ~ nUMI", "percent.mito)
# mDAT <- estimateDispersions(mDAT)
mDAT <- preprocessCDS(mDAT, num_dim = 20, residualModelFormulaStr = "~ nUMI + percent.mito")
set.seed(1) # Monocle sets their seed to 2016 by default (Seurat sets it to 1)
# Dimensionality Reduction
# Options: c("UMAP", "tSNE", "DDRTree", "ICA", "none")
# mDAT <- reduceDimension(mDAT, reduction_method = 'UMAP', n_threads =  parallel::detectCores())
# monocle:::UMAP( )
mDAT <- reduceDimension(mDAT, reduction_method = 'tSNE',
perplexity = 30,
num_threads = parallel::detectCores())
col_vector_origin <- c("#db83da",
"#53c35d",
"#a546bb",
"#83b837",
"#a469e6",
"#babb3d",
"#4f66dc",
"#e68821",
"#718fe8",
"#d6ac3e",
"#7957b4",
"#468e36",
"#d347ae",
"#5dbf8c",
"#e53e76",
"#42c9b8",
"#dd454a",
"#3bbac6",
"#d5542c",
"#59aadc",
"#cf8b36",
"#4a61b0",
"#8b8927",
"#a24e99",
"#9cb36a",
"#ca3e87",
"#36815b",
"#b23c4e",
"#5c702c",
"#b79add",
"#a55620",
"#5076af",
"#e38f67",
"#85609c",
"#caa569",
"#9b466c",
"#88692c",
"#dd81a9",
"#a35545",
"#e08083",
"#17becf",
"#9edae5")
plotDR <- function(mDAT, metavar="Cluster", title=""){
col_vector <- col_vector_origin[1:length(unique(as.character(pData(mDAT)$dx)))]
names(col_vector) <- unique(as.character(pData(mDAT)$dx))
p <- plot_cell_clusters(mDAT,
color_by = metavar,
cell_size = 0.5,
show_group_id = T)  +
theme(legend.text=element_text(size=6)) +
theme(legend.position="right")+
labs(title = paste(title))
print(p)
}
plotDR(mDAT, "dx")
test_resolutions <- function(mDAT, resolutions=seq(0, 1e-4, length.out = 10)){
for(res in resolutions){
res_title <- paste("Resolution =",res)
cat("\n",res_title,"\n")
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = F, cores = parallel::detectCores())
plotDR(resDAT, title=res_title)
}
}
test_resolutions <- function(mDAT, resolutions=seq(0, 1e-4, length.out = 6)){
for(res in resolutions){
res_title <- paste("Resolution =",res)
cat("\n",res_title,"\n")
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = F, cores = parallel::detectCores())
plotDR(resDAT, title=res_title)
}
}
test_resolutions(mDAT)
test_resolutions <- function(mDAT, resolutions=seq(0, 1e-2, length.out = 6)){
for(res in resolutions){
res_title <- paste("Resolution =",res)
cat("\n",res_title,"\n")
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = F,
cores = parallel::detectCores())
plotDR(resDAT, title=res_title)
}
}
test_resolutions(mDAT)
test_resolutions <- function(mDAT, resolutions=seq(0, 1e-4, length.out = 6)){
for(res in resolutions){
res_title <- paste("Resolution =",res)
cat("\n",res_title,"\n")
resDAT <- clusterCells(mDAT, res=res,
method = "louvain",
verbose = F,
cores = parallel::detectCores())
plotDR(resDAT, title=res_title)
}
}
test_resolutions(mDAT)
selected_res <- 1e-4
mDAT <- clusterCells(mDAT, res=selected_res,
method = "louvain",
verbose = T, cores = parallel::detectCores())
plotDR(mDAT, "Cluster")
plot_cell_clusters(mDAT, markers = c("CD14","FCGR3A"), cell_size = 0.5)
plot_cell_clusters(mDAT, markers = c("LRRK2","GBA", overlappingGenes_PD), cell_size = 0.5)
plot_cell_clusters(mDAT, markers = c("MS4A4A","MS4A6A"), cell_size = 0.5)
mDAT <- partitionCells(mDAT)
mDAT <- learnGraph(mDAT,  RGE_method = 'SimplePPT')
plot_cell_trajectory(mDAT, color_by = "dx")
plot_cell_trajectory(mDAT, color_by = "mut")
plot_cell_trajectory(mDAT, color_by = "cell_type")
plot_cell_trajectory(mDAT, color_by = "Cluster")
plot_3d_cell_trajectory(mDAT,
color_by="cell_type",
webGL_filename= paste(getwd(), "/trajectory_3D.html", sep=""),
show_backbone=TRUE,
useNULL_GLdev=TRUE)
plot_3d_cell_trajectory(mDAT, markers = c('FCGR3A'),
webGL_filename=paste(getwd(), "/beta_globin.html", sep=""),
show_backbone=TRUE,
useNULL_GLdev=TRUE)
monocle::plot_pseudotime_heatmap(mDAT)
plotDR(mDAT, "post_clustering")
DEG_df <- differentialGeneTest(mDAT, fullModelFormulaStr = "~Cluster",
cores = parallel::detectCores())
DEG_df
