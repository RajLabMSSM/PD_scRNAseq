right = F,
labels = AgeGroupsUniq,
nclude.lowest=T)]
metadata <- data.frame(metadata)
unique(metadata$AgeGroups)
head(metadata)
dim(metadata)
return(metadata)
}
# metadata <- makeAgeGroups()
DAT <- AddMetaData(object = DAT, metadata = metadata)
# Get rid of any NAs (cells that don't match up with the metadata)
if(subsetCells==F){
DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0)
} else {DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0,
# Subset for testing
cells.use = DAT@cell.names[0:subsetCells]
)
}
subsetCells
subsetBiotypes <- function(DAT, subsetGenes){
if( subsetGenes!=F ){
cat(paste("Subsetting genes:",subsetGenes, "\n"))
# If the gene_biotypes file exists, import csv. Otherwise, get from biomaRt
if(file_test("-f", file.path(root, "Data/gene_biotypes.csv"))){
biotypes <- read.csv(file.path(root, "Data/gene_biotypes.csv"))
}
else {
ensembl <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org",
dataset="hsapiens_gene_ensembl")
ensembl <- useDataset(mart = ensembl, dataset = "hsapiens_gene_ensembl")
listFilters(ensembl)
listAttributes(ensembl)
biotypes <- getBM(attributes=c("hgnc_symbol", "gene_biotype"), filters="hgnc_symbol",
values=row.names(DAT@data), mart=ensembl)
write.csv(biotypes, file.path(root,"Data/gene_biotypes.csv"), quote=F, row.names=F)
}
# Subset data by creating new Seurat object (annoying but necessary)
geneSubset <- biotypes[biotypes$gene_biotype==subsetGenes,"hgnc_symbol"]
cat(paste(dim(DAT@raw.data[geneSubset, ])[1],"/", dim(DAT@raw.data)[1],
"genes are", subsetGenes))
# Add back into DAT
subset.matrix <- DAT@raw.data[geneSubset, ] # Pull the raw expression matrix from the original Seurat object containing only the genes of interest
DAT_sub <- CreateSeuratObject(subset.matrix) # Create a new Seurat object with just the genes of interest
orig.ident <- row.names(DAT@meta.data) # Pull the identities from the original Seurat object as a data.frame
DAT_sub <- AddMetaData(object = DAT_sub, metadata = DAT@meta.data) # Add the idents to the meta.data slot
DAT_sub <- SetAllIdent(object = DAT_sub, id = "ident") # Assign identities for the new Seurat object
DAT <- DAT_sub
rm(list = c("DAT_sub","geneSubset", "subset.matrix", "orig.ident"))
}
return(DAT)
}
DAT <- subsetBiotypes(DAT, subsetGenes)
subsetBiotypes <- function(DAT, subsetGenes){
if( subsetGenes!=F ){
cat(paste("Subsetting genes:",subsetGenes, "\n"))
# If the gene_biotypes file exists, import csv. Otherwise, get from biomaRt
if(file_test("-f", file.path(root, "Data/gene_biotypes.csv"))){
biotypes <- read.csv(file.path(root, "Data/gene_biotypes.csv"))
}
else {
ensembl <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org",
dataset="hsapiens_gene_ensembl")
ensembl <- useDataset(mart = ensembl, dataset = "hsapiens_gene_ensembl")
listFilters(ensembl)
listAttributes(ensembl)
biotypes <- getBM(attributes=c("hgnc_symbol", "gene_biotype"), filters="hgnc_symbol",
values=row.names(DAT@data), mart=ensembl)
write.csv(biotypes, file.path(root,"Data/gene_biotypes.csv"), quote=F, row.names=F)
}
# Subset data by creating new Seurat object (annoying but necessary)
geneSubset <- biotypes[biotypes$gene_biotype==subsetGenes,"hgnc_symbol"]
cat(paste(dim(DAT@raw.data[geneSubset, ])[1],"/", dim(DAT@raw.data)[1],
"genes are", subsetGenes))
# Add back into DAT
subset.matrix <- DAT@raw.data[geneSubset, ] # Pull the raw expression matrix from the original Seurat object containing only the genes of interest
DAT_sub <- CreateSeuratObject(subset.matrix) # Create a new Seurat object with just the genes of interest
orig.ident <- row.names(DAT@meta.data) # Pull the identities from the original Seurat object as a data.frame
DAT_sub <- AddMetaData(object = DAT_sub, metadata = DAT@meta.data) # Add the idents to the meta.data slot
DAT_sub <- SetAllIdent(object = DAT_sub, id = "ident") # Assign identities for the new Seurat object
DAT <- DAT_sub
rm(list = c("DAT_sub","geneSubset", "subset.matrix", "orig.ident"))
}
return(DAT)
}
DAT <- subsetBiotypes(DAT, subsetGenes)
metadata <- read.table(file.path(root,"Data/meta.data4.tsv"))
createDT( metadata[1:100,], caption = "Metadata")
# Make AgeGroups
makeAgeGroups <- function(){
dim(metadata)
getMaxRound <- function(vals=metadata$Age, unit=10)unit*ceiling((max(vals)/unit))
getMinRound <- function(vals=metadata$Age, unit=10)unit*floor((min(vals)/unit))
ageBreaks = c(seq(getMinRound(), getMaxRound(), by = 10), getMaxRound()+10)
AgeGroupsUniq <- c()
for (i in 1:(length(ageBreaks)-1)){
AgeGroupsUniq <- append(AgeGroupsUniq, paste(ageBreaks[i],ageBreaks[i+1], sep="-"))
}
data.table::setDT(metadata,keep.rownames = T,check.names = F)[, AgeGroups := cut(Age,
breaks = ageBreaks,
right = F,
labels = AgeGroupsUniq,
nclude.lowest=T)]
metadata <- data.frame(metadata)
unique(metadata$AgeGroups)
head(metadata)
dim(metadata)
return(metadata)
}
# metadata <- makeAgeGroups()
DAT <- AddMetaData(object = DAT, metadata = metadata)
# Get rid of any NAs (cells that don't match up with the metadata)
if(subsetCells==F){
DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0)
} else {DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0,
# Subset for testing
cells.use = DAT@cell.names[0:subsetCells]
)
}
subsetCells
subsetCells==F
DAT@cell.names[0:subsetCells]
subsetCells
DAT@cell.names[0:subsetCells[[1]] ]
metadata <- read.table(file.path(root,"Data/meta.data4.tsv"))
createDT( metadata[1:100,], caption = "Metadata")
# Make AgeGroups
makeAgeGroups <- function(){
dim(metadata)
getMaxRound <- function(vals=metadata$Age, unit=10)unit*ceiling((max(vals)/unit))
getMinRound <- function(vals=metadata$Age, unit=10)unit*floor((min(vals)/unit))
ageBreaks = c(seq(getMinRound(), getMaxRound(), by = 10), getMaxRound()+10)
AgeGroupsUniq <- c()
for (i in 1:(length(ageBreaks)-1)){
AgeGroupsUniq <- append(AgeGroupsUniq, paste(ageBreaks[i],ageBreaks[i+1], sep="-"))
}
data.table::setDT(metadata,keep.rownames = T,check.names = F)[, AgeGroups := cut(Age,
breaks = ageBreaks,
right = F,
labels = AgeGroupsUniq,
nclude.lowest=T)]
metadata <- data.frame(metadata)
unique(metadata$AgeGroups)
head(metadata)
dim(metadata)
return(metadata)
}
# metadata <- makeAgeGroups()
DAT <- AddMetaData(object = DAT, metadata = metadata)
# Get rid of any NAs (cells that don't match up with the metadata)
if(subsetCells==F){
DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0)
} else {DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0,
# Subset for testing
cells.use = DAT@cell.names[0:subsetCells[[1]] ]
)
}
DAT
params$subsetCells
# Get rid of any NAs (cells that don't match up with the metadata)
if(params$subsetCells==F){
DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0)
} else {DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0,
# Subset for testing
cells.use = DAT@cell.names[0:params$subsetCells ]
)
}
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
load(file.path(resultsPath, "scRNAseq_results.RData"))
load(file.path(resultsPath,
"subsetGenes-protein_coding__subsetCells-400__Resolution-0.2__perplexity-30__nCores-4",
"scRNAseq_results.RData"))
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
load(file.path(resultsPath, "scRNAseq_results.RData"))
library(Seurat)
library(dplyr)
library(gridExtra)
library(knitr)
library(plotly)
library(ggplot2)
library(viridis)
library(reshape2)
library(shiny)
library(ggrepel)
library(DT)
library(ComplexHeatmap); #BiocManager::install("ComplexHeatmap")
## Install Bioconductor
#  if (!requireNamespace("BiocManager"))
#     install.packages("BiocManager")
library(biomaRt) # BiocManager::install(c("biomaRt"))
# library(DESeq2) # BiocManager::install(c("DESeq2"))
library(enrichR) #BiocManager::install("enrichR")
library(monocle) #BiocManager::install("monocle")
# BiocManager::install("DelayedMatrixStats")
# BiocManager::install("org.Mm.eg.db")
library(org.Hs.eg.db)
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
sessionInfo()
print(paste("Seurat ", packageVersion("Seurat")))
# Limit to only top variable genes?:
# Set arg 'only.pos=F' to capture negative biomarkers
# DAT <- SetIdent(DAT, ident.use = "post_clustering")
DAT.markers <- FindAllMarkers(object = DAT, min.pct = 0.25, thresh.use = 0.25,  only.pos = F,
test.use = "wilcox") # DESeq2
DAT.markers <- DAT.markers %>% mutate(FC = 2^avg_logFC)
DAT.markers.sig <- DAT.markers %>% subset(p_val_adj<=0.05)
markers.summary <- DAT.markers.sig %>% group_by(cluster) %>% tally()
# markers.summary <- base::merge(DAT.markers.sig %>% group_by(cluster) %>% tally(),
#       DAT.markers %>% group_by(cluster) %>% summarise(mean(avg_logFC)),
#       by="cluster" )
createDT(markers.summary, caption = "Number of DEGs and Mean logFC per Cluster")
createDT(DAT.markers, caption = paste("All Biomarkers: All Clusters"))
load(file.path(resultsPath, "scRNAseq_results.RData"))
load(file.path('Results","scRNAseq_results.RData"))
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
load(file.path(resultsPath, "scRNAseq_results.RData"))
# load(file.path('Results","scRNAseq_results.RData"))
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
load(file.path(resultsPath, "scRNAseq_results.RData"))
library(Seurat)
library(dplyr)
library(gridExtra)
library(knitr)
library(plotly)
library(ggplot2)
library(viridis)
library(reshape2)
library(shiny)
library(ggrepel)
library(DT)
library(ComplexHeatmap); #BiocManager::install("ComplexHeatmap")
## Install Bioconductor
#  if (!requireNamespace("BiocManager"))
#     install.packages("BiocManager")
library(biomaRt) # BiocManager::install(c("biomaRt"))
# library(DESeq2) # BiocManager::install(c("DESeq2"))
library(enrichR) #BiocManager::install("enrichR")
library(monocle) #BiocManager::install("monocle")
# BiocManager::install("DelayedMatrixStats")
# BiocManager::install("org.Mm.eg.db")
library(org.Hs.eg.db)
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
sessionInfo()
print(paste("Seurat ", packageVersion("Seurat")))
# Limit to only top variable genes?:
# Set arg 'only.pos=F' to capture negative biomarkers
# DAT <- SetIdent(DAT, ident.use = "post_clustering")
DAT.markers <- FindAllMarkers(object = DAT, min.pct = 0.25, thresh.use = 0.25,  only.pos = F,
test.use = "wilcox") # DESeq2
DAT.markers <- DAT.markers %>% mutate(FC = 2^avg_logFC)
DAT.markers.sig <- DAT.markers %>% subset(p_val_adj<=0.05)
markers.summary <- DAT.markers.sig %>% group_by(cluster) %>% tally()
# markers.summary <- base::merge(DAT.markers.sig %>% group_by(cluster) %>% tally(),
#       DAT.markers %>% group_by(cluster) %>% summarise(mean(avg_logFC)),
#       by="cluster" )
createDT(markers.summary, caption = "Number of DEGs and Mean logFC per Cluster")
createDT(DAT.markers, caption = paste("All Biomarkers: All Clusters"))
topNum = 5
topBiomarkers <- DAT.markers %>% group_by(cluster) %>% top_n(topNum, avg_logFC)
createDT(DAT.markers, caption = paste("All Biomarkers: All Clusters"))
getTopBiomarker <- function(DAT.markers, clusterID, topN=1){
df <-DAT.markers %>%
subset(p_val_adj<0.05 & cluster==as.character(clusterID)) %>%
arrange(desc(avg_logFC))
top_pct_markers <- df[1:topN,"gene"]
return(top_pct_markers)
}
# clust1_biomarkers <- getTopBiomarker(DAT.markers, clusterID=1, topN=2)
# clust2_biomarkers <- getTopBiomarker(DAT.markers, clusterID=2, topN=2)
### Plot biomarkers
plotBiomarkers <- function(DAT, biomarkers, cluster){
biomarkerPlots <- list()
for (marker in biomarkers){
p <- VlnPlot(object = DAT, features.plot = c(marker), y.log=T, return.plotlist=T)
biomarkerPlots[[marker]] <- p + ggplot2::aes(alpha=0.5) + xlab( "Cluster") + ylab( "Expression")
}
combinedPlot <- do.call(grid.arrange, c(biomarkerPlots, list(ncol=2, top=paste("Top DEG Biomarkers for Cluster",cluster))) )
# biomarkerPlots <- lapply(biomarkers, function(marker) {
#   VlnPlot(object = DAT, features.plot = c(marker), y.log=T, return.plotlist=T) %>% + ggplot2::ggtitle(marker) %>% ggplotly()
# })
# return(subplot(biomarkerPlots) )
}
top1 <- DAT.markers %>% group_by(cluster) %>% top_n(1, avg_logFC)
nCols <- floor( sqrt(length(unique(top1$cluster))) )
figHeight <- nCols *7
# Plot top 2 biomarker genes for each
for (clust in unique(DAT.markers$cluster)){
cat('\n')
cat("### Cluster ",clust,"\n")
biomarkers <- getTopBiomarker(DAT.markers, clusterID=clust, topN=2)
plotBiomarkers(DAT, biomarkers, clust)
cat('\n')
}
##Construct the plot object
volcanoPlot <- function(DEG_df, caption="", topFC_labeled=5){
DEG_df$sig<-  ifelse( DEG_df$p_val_adj<0.05 & DEG_df$avg_logFC<1.5, "p_val_adj<0.05",
ifelse( DEG_df$p_val_adj<0.05  & DEG_df$avg_logFC>1.5, "p_val_adj<0.05 & avg_logFC>1.5",
"p_val_adj>0.05"
))
DEG_df <- arrange(DEG_df, desc(sig))
yMax  <- max(-log10(DEG_df$p_val_adj)) + max(-log10(DEG_df$p_val_adj))/3 #ifelse(max(-log10(DEG_df$p_val_adj))<45, 50, max(-log10(DEG_df$p_val_adj)) + 10)
vol <- ggplot(data=DEG_df, aes(x=avg_logFC, y= -log10(p_val_adj))) +
geom_point(alpha=0.5, size=3, aes(col=sig)) +
scale_color_manual(values=list("p_val_adj<0.05"="turquoise3",
"p_val_adj<0.05 & avg_logFC>1.5"="purple",
"p_val_adj>0.05" = "darkgray")) +
theme(legend.position = "none") +
xlab(expression(paste("Average ",log^{2},"(fold change)"))) +
ylab(expression(paste(-log^{10},"(p-value)"))) + xlim(-2,2) + ylim(0, yMax) +
## ggrepl labels
geom_text_repel(data= arrange(DEG_df,  p_val_adj, desc(avg_logFC))[1:topFC_labeled,],
# filter(DEG_df, avg_logFC>=1.5)[1:10,],
aes(label=gene),  color="black", alpha=.5,
segment.color="black", segment.alpha=.5
) +
# Lines
geom_vline(xintercept= -1.5,lty=4, lwd=.3, alpha=.5) +
geom_vline(xintercept= 1.5,lty=4, lwd=.3, alpha=.5) +
geom_hline(yintercept= -log10(0.05),lty=4, lwd=.3, alpha=.5) +
ggtitle(caption)
print(vol)
}
# Run plots
for (clust in unique(DAT.markers$cluster)){
cat('\n')
cat("### Cluster ",clust,": Volcano","\n")
cap <- paste("Cluster",clust,"DEG Table")
DEG_df <- subset(DAT.markers, cluster==as.character(clust)) %>% arrange(desc(avg_logFC))
volcanoPlot(DEG_df, caption = cap)
createDT_html(DEG_df, caption = cap)
cat('\n')
}
for (clust in top1$cluster){
subClust <- subset( top1, cluster==clust)
cat('\n')
cat("### Cluster",clust,"\n")
cat( "Biomarker\n",subClust$gene)
results <- Seurat::FindGeneTerms(QueryGene = subClust$gene)
print(results) #parse_html_notebook(results)
cat('\n')
}
fp <- FeaturePlot(object = DAT, features.plot = top1$gene, cols.use = c("grey", "purple"),
reduction.use = "tsne", nCol = nCols, do.return = T)
top5 <- DAT.markers %>% group_by(cluster) %>% top_n(5, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = DAT, genes.use = top5$gene, slim.col.label=T, remove.key=T)
# ifelse(interactive, p %>% ggplotly() %>% toWebGL() %>% print(), print(p))
RidgePlot(DAT, features.plot = top1$gene,  nCol = nCols, do.sort = F)
top2 <- DAT.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
sdp <- SplitDotPlotGG(DAT, genes.plot = top2$gene, cols.use = c("blue","red"),
x.lab.rot = T, plot.legend = T, dot.scale = 8, do.return = T, grouping.var = "dx")
markerList <- c("CD14", "FCGR3A")
get_markerDF <- function(DAT, markerList, meta_vars =c("barcode", "dx", "mut","post_clustering", "percent.mito","nGene", "nUMI")){
exp <- DAT@scale.data %>% data.frame()
marker.matrix <- exp[row.names(exp) %in% markerList, ]
marker.matrix$Gene <- row.names(marker.matrix)
markerMelt <- reshape2:::melt.data.frame(marker.matrix, id.vars = "Gene", variable.name = "Cell",value.name = "Expression")
metaSelect <-  DAT@meta.data[,meta_vars]
markerDF <- merge(markerMelt,metaSelect, by.x="Cell", by.y="barcode")
return(markerDF)
}
markerDF <- get_markerDF(DAT, markerList)
createDT(markerDF, caption = "Known Marker Expression")
# Explore expression differences between groups
marker_vs_metadata <- function(markerDF, meta_var){
# Create title from ANOVA summary
ANOVAtitle <- function(markerDF, marker){
nTests <- length(unique(markerDF$Gene))
res <- anova(lm(data = subset(markerDF, Gene==marker),
formula = Expression ~ eval(parse(text=meta_var))))
title <-paste(paste("ANOVA (",marker, " vs. ",meta_var, ")", sep=""),
": p=",round(res$`Pr(>F)`,3),
", F=",round(res$`F value`,3),
ifelse(res$`Pr(>F)`<.05/nTests,"(Significant**)",
"(Non-significant)") )
}
title = ""
for (marker in unique(markerDF$Gene) ){
cat(marker)
title <- paste(title, "\n", ANOVAtitle(markerDF, marker))
}
ggplot(markerDF, aes(x=eval(parse(text=meta_var)), y=Expression, fill= Gene)) +
geom_violin() +
geom_point( position=position_jitterdodge(jitter.width = .2, dodge.width = .9 ),   alpha=0.6, color="turquoise3") +
labs(title = title, x=meta_var) +
theme(plot.title = element_text( size=10)) +
scale_fill_manual(values=c("brown", "slategray"))
}
marker_vs_metadata(markerDF, "dx")
marker_vs_metadata(markerDF, "mut")
# load("DAT.R")
# Convert Seurat objt to CDS object
mDAT <- monocle::importCDS(DAT,  import_all = T)
# generate size factors for normalization later
mDAT <- estimateSizeFactors(mDAT)
# Get pre-trained PBMC classifer
load("./Garnet/hsPBMC") # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
library(biomaRt) # BiocManager::install(c("biomaRt"))
# library(DESeq2) # BiocManager::install(c("DESeq2"))
library(enrichR) #BiocManager::install("enrichR")
library(monocle) #BiocManager::install("monocle")
# BiocManager::install("DelayedMatrixStats")
library(org.Hs.eg.db)
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
# load("DAT.R")
# Convert Seurat objt to CDS object
mDAT <- monocle::importCDS(DAT,  import_all = T)
# generate size factors for normalization later
mDAT <- estimateSizeFactors(mDAT)
# Get pre-trained PBMC classifer
load("./Garnet/hsPBMC") # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
# Get pre-trained PBMC classifer
load("./Data/Garnet/hsPBMC") # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
# Get pre-trained PBMC classifer
load("./Data/Garnett/hsPBMC") # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
# Get feature genes for each cell type
feature_genes <- get_feature_genes(classifier = hsPBMC,
node = "root",
db = org.Hs.eg.db,
convert_ids = T)
# BiocManager::install("DelayedMatrixStats")
BiocManager::install(c('DelayedArray', 'DelayedMatrixStats', 'org.Hs.eg.db', 'org.Mm.eg.db'))
library(enrichR) #BiocManager::install("enrichR")
library(monocle) #BiocManager::install("monocle")
library(org.Hs.eg.db)
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
# generate size factors for normalization later
mDAT <- estimateSizeFactors(mDAT)
# Get pre-trained PBMC classifer
load("./Data/Garnett/hsPBMC") # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
# Get feature genes for each cell type
feature_genes <- get_feature_genes(classifier = hsPBMC,
node = "root",
db = org.Hs.eg.db,
convert_ids = T)
devtools::install_github("cole-trapnell-lab/garnett")
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
# load("DAT.R")
# Convert Seurat objt to CDS object
mDAT <- monocle::importCDS(DAT,  import_all = T)
# generate size factors for normalization later
mDAT <- estimateSizeFactors(mDAT)
# Get pre-trained PBMC classifer
load("./Data/Garnett/hsPBMC") # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC
# Get feature genes for each cell type
feature_genes <- get_feature_genes(classifier = hsPBMC,
node = "root",
db = org.Hs.eg.db,
convert_ids = T)
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
install.packages("BiocManager")
BiocManager::install()
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
load(file.path(resultsPath, "scRNAseq_results.RData"))
# load(file.path('Results","scRNAseq_results.RData"))
remove.packages("monocle")
install.packages("BiocManager")
BiocManager::install()
BiocManager::install(c("monocle"))
devtools::install_github("cole-trapnell-lab/monocle")
library(monocle) # BiocManager::install("monocle")
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
# Import functions
root = "./"
source(file.path(root,"general_functions.R"))
import_parameters(params)
load(file.path(resultsPath, "scRNAseq_results.RData"))
library(monocle) # BiocManager::install("monocle")
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
# load("DAT.R")
# Convert Seurat objt to CDS object
mDAT <- monocle::importCDS(DAT,  import_all = T)
# load("DAT.R")
# Convert Seurat objt to CDS object
mDAT <- importCDS(DAT,  import_all = T)
devtools::uninstall("monocle")
devtools::uninstall("cole-trapnell-/monocle")
devtools::uninstall("cole-trapnell/monocle")
devtools::uninstall(monocle)
remove.packages("monocle")
remove.packages(monocle)
remove.packages("monocle")
dev_mode(true)
devtools::dev_mode(true)
devtools::dev_mode(T)
remove.packages('monocle')
# devtools::install_github("cole-trapnell-lab/monocle")
.libPaths()
remove.packages('/Users/schilder/R-devmonocle')
remove.packages('/Users/schilder/R-dev/monocle')
BiocManager::install(c("monocle"))
BiocManager::install(c("monocle"))
library(monocle) # BiocManager::install("monocle")
library(monocle) # BiocManager::install("monocle")
