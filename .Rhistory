pbmc <- StashIdent(pbmc, save.name = meta_var)
DEGs <- FindMarkers(pbmc, ident.1=group1, ident.2=group2, test.use=test.use)
DEGs$gene <- row.names(DEGs)
return(DEGs)
}
volcanoPlot(df, caption = cap)
# Available DGE methods:
## "wilcox", "bimod", "roc", "t", "tobit", "poisson", "negbinom", "MAST", "DESeq2"
runDGE <- function(pbmc, meta_var, group1, group2, test.use="wilcox"){
#print(paste("DGE_allCells",meta_var,sep="_"))
# groups <- pbmc@meta.data[,meta_var] %>% unique()
pbmc <- SetAllIdent(pbmc, id = meta_var)
pbmc <- StashIdent(pbmc, save.name = meta_var)
DEGs <- FindMarkers(pbmc, ident.1=group1, ident.2=group2, test.use=test.use)
DEGs$gene <- row.names(DEGs)
return(DEGs)
}
volcanoPlot(df, caption = cap)
getClusterDEGs <- function(pbmc.markers, clusterID){
DF <- pbmc.markers
DF <- subset(DF, clusterID==as.character(clusterID)) %>% arrange(desc(avg_logFC))
return(DF)
}
##Construct the plot object
volcanoPlot <- function(DEG_df, caption="", topFC_labeled=5){
DEG_df$sig<-  ifelse( DEG_df$p_val_adj<0.05 & DEG_df$avg_logFC<1.5, "p_val_adj<0.05",
ifelse( DEG_df$p_val_adj<0.05  & DEG_df$avg_logFC>1.5, "p_val_adj<0.05 & avg_logFC>1.5",
"p_val_adj>0.05"
))
DEG_df <- arrange(DEG_df, desc(sig))
vol <- ggplot(data=DEG_df, aes(x=avg_logFC, y= -log10(p_val_adj))) +
geom_point(alpha=0.5, size=3, aes(col=sig)) +
scale_color_manual(values=list("p_val_adj<0.05"="turquoise3",
"p_val_adj<0.05 & avg_logFC>1.5"="purple",
"p_val_adj>0.05" = "darkgray")) +
theme(legend.position = "none") +
xlab(expression(paste("Average ",log^{2},"(fold change)"))) +
ylab(expression(paste(-log^{10},"(p-value)"))) + xlim(-2,2) +
## ggrepl labels
geom_text_repel(data= arrange(DEG_df, desc(avg_logFC))[1:topFC_labeled,],
# filter(DEG_df, avg_logFC>=1.5)[1:10,],
aes(label=gene),  color="black", alpha=.5,
segment.color="black", segment.alpha=.5
# arrow=arrow(type="closed", angle = 10)
) +
# Lines
geom_vline(xintercept= -1.5,lty=4, lwd=.3, alpha=.5) +
geom_vline(xintercept= 1.5,lty=4, lwd=.3, alpha=.5) +
geom_hline(yintercept= -log10(0.05),lty=4, lwd=.3, alpha=.5) +
ggtitle(caption)
print(vol)
}
for (clust in unique(pbmc.markers$cluster)){
cat('\n')
cat("### Cluster ",clust,"\n")
DEG_df <- getClusterDEGs(pbmc.markers, clust)
volcanoPlot(DEG_df, caption)
createDT(DEG_df, caption = paste("Cluster",clust,"DEG Table"))
cat('\n')
}
df <-runDGE(pbmc, "dx", group1 = "PD", group1="control")
df <-runDGE(pbmc, "dx", group1 = "PD", group2="control")
cap = paste("DEGs (All Cells): PD vs. Controls")
createDT(df, caption = cap)
volcanoPlot(df, caption = cap)
df <-runDGE(pbmc, "dx", group1 = "PD", group2="control")
cap = paste("DEGs (All Cells): PD vs. Controls")
createDT(df, caption = cap)
volcanoPlot(df, caption = cap)
df <-runDGE(pbmc, "mut", "LRRK2", "PD")
createDT(df, caption = paste("DEGs (All Cells): LRRK2 vs. PD"))
df <-runDGE(pbmc, "mut", "LRRK2", "PD")
cap <- paste("DEGs (All Cells): LRRK2 vs. PD")
createDT(df, caption = cap)
volcanoPlot(df, caption = cap)
volcanoPlot(df, caption = cap, topFC_labeled = 5)
volcanoPlot(df, caption = cap, topFC_labeled = 2)
DEG_df
DF
library(Seurat)
library(dplyr)
library(gridExtra)
library(knitr)
library(plotly)
library(ggplot2)
library(reshape2)
library(shiny)
library(ggrepel)
library(DT)
createDT <- function(DF, caption="", scrollY=500){
data <- datatable(DF, caption=caption,
extensions = 'Buttons',
options = list( dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
scrollY = scrollY, paging = F
)
)
print(data)
}
#
# install.packages('devtools')
# devtools::install_github('talgalili/heatmaply')
## Install Bioconductor
#  if (!requireNamespace("BiocManager"))
#     install.packages("BiocManager")
# BiocManager::install(c("biomaRt"))
library(biomaRt)
# BiocManager::install(c("DESeq2"))
library(DESeq2)
# Useful Seurat functions
## Seurat::FindGeneTerms() # Enrichr API
## Seurat::MultiModal_CCA() # Integrates data from disparate datasets (CIA version too)
sessionInfo()
print(paste("Seurat ", packageVersion("Seurat")))
getClusterDEGs <- function(pbmc.markers, clusterID){
DF <- pbmc.markers
DF <- subset(DF, clusterID==as.character(clusterID)) %>% arrange(desc(avg_logFC))
return(DF)
}
##Construct the plot object
volcanoPlot <- function(DEG_df, caption="", topFC_labeled=5){
DEG_df$sig<-  ifelse( DEG_df$p_val_adj<0.05 & DEG_df$avg_logFC<1.5, "p_val_adj<0.05",
ifelse( DEG_df$p_val_adj<0.05  & DEG_df$avg_logFC>1.5, "p_val_adj<0.05 & avg_logFC>1.5",
"p_val_adj>0.05"
))
DEG_df <- arrange(DEG_df, desc(sig))
vol <- ggplot(data=DEG_df, aes(x=avg_logFC, y= -log10(p_val_adj))) +
geom_point(alpha=0.5, size=3, aes(col=sig)) +
scale_color_manual(values=list("p_val_adj<0.05"="turquoise3",
"p_val_adj<0.05 & avg_logFC>1.5"="purple",
"p_val_adj>0.05" = "darkgray")) +
theme(legend.position = "none") +
xlab(expression(paste("Average ",log^{2},"(fold change)"))) +
ylab(expression(paste(-log^{10},"(p-value)"))) + xlim(-2,2) +
## ggrepl labels
geom_text_repel(data= arrange(DEG_df, desc(avg_logFC))[1:topFC_labeled,],
# filter(DEG_df, avg_logFC>=1.5)[1:10,],
aes(label=gene),  color="black", alpha=.5,
segment.color="black", segment.alpha=.5
) +
# Lines
geom_vline(xintercept= -1.5,lty=4, lwd=.3, alpha=.5) +
geom_vline(xintercept= 1.5,lty=4, lwd=.3, alpha=.5) +
geom_hline(yintercept= -log10(0.05),lty=4, lwd=.3, alpha=.5) +
ggtitle(caption)
print(vol)
}
for (clust in unique(pbmc.markers$cluster)){
cat('\n')
cat("### Cluster ",clust,"\n")
DEG_df <- getClusterDEGs(pbmc.markers, clust)
volcanoPlot(DEG_df, caption)
createDT(DEG_df, caption = paste("Cluster",clust,"DEG Table"))
cat('\n')
}
df <-runDGE(pbmc, "dx", group1 = "PD", group2="control")
cap = paste("DEGs (All Cells): PD vs. Controls")
createDT(df, caption = cap)
volcanoPlot(df, caption = cap)
df <-runDGE(pbmc, "mut", "LRRK2", "PD")
cap <- paste("DEGs (All Cells): LRRK2 vs. PD")
createDT(df, caption = cap)
volcanoPlot(df, caption = cap)
resultsPath=file.path(getwd(),"Results")
# Gather parameters from command line
#dir.create(file.path(resultsPath,"cache"), showWarnings=F, recursive=T)
nCores <- parallel::detectCores()#params$nCores
subsetGenes <- params$subsetGenes
subsetCells <- params$subsetCells
resolution <-  as.numeric(params$resolution)
root <- getwd()
# Have to setwd via knitr
# knitr::opts_knit$set(root.dir=resultsPath, child.path = resultsPath)
knitr::opts_chunk$set(echo=T, error=T, root.dir = resultsPath#cache=T, cache.lazy=T,
)
# kableStyle = c("striped", "hover", "condensed", "responsive")
# Utilize parallel processing later on
print(paste("**** Utilized Cores **** =", nCores))
params
library(Seurat)
library(dplyr)
library(gridExtra)
library(knitr)
library(plotly)
library(ggplot2)
library(reshape2)
library(shiny)
library(ggrepel)
library(DT)
createDT <- function(DF, caption="", scrollY=500){
data <- datatable(DF, caption=caption,
extensions = 'Buttons',
options = list( dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
scrollY = scrollY, paging = F
)
)
print(data)
}
#
# install.packages('devtools')
# devtools::install_github('talgalili/heatmaply')
## Install Bioconductor
#  if (!requireNamespace("BiocManager"))
#     install.packages("BiocManager")
# BiocManager::install(c("biomaRt"))
library(biomaRt)
# BiocManager::install(c("DESeq2"))
library(DESeq2)
# Useful Seurat functions
## Seurat::FindGeneTerms() # Enrichr API
## Seurat::MultiModal_CCA() # Integrates data from disparate datasets (CIA version too)
sessionInfo()
print(paste("Seurat ", packageVersion("Seurat")))
#setwd("~/Desktop/PD_scRNAseq/")
dir.create(file.path(root,"Data"), showWarnings=F)
load(file.path(root,"Data/seurat_object_add_HTO_ids.Rdata"))
pbmc <- seurat.obj
rm(seurat.obj)
pbmc
metadata <- read.table(file.path(root,"Data/meta.data4.tsv"))
createDT( metadata, caption = "Metadata")
# Make AgeGroups
makeAgeGroups <- function(){
dim(metadata)
getMaxRound <- function(vals=metadata$Age, unit=10)unit*ceiling((max(vals)/unit))
getMinRound <- function(vals=metadata$Age, unit=10)unit*floor((min(vals)/unit))
ageBreaks = c(seq(getMinRound(), getMaxRound(), by = 10), getMaxRound()+10)
AgeGroupsUniq <- c()
for (i in 1:(length(ageBreaks)-1)){
AgeGroupsUniq <- append(AgeGroupsUniq, paste(ageBreaks[i],ageBreaks[i+1], sep="-"))
}
data.table::setDT(metadata,keep.rownames = T,check.names = F)[, AgeGroups := cut(Age,
breaks = ageBreaks,
right = F,
labels = AgeGroupsUniq,
nclude.lowest=T)]
metadata <- data.frame(metadata)
unique(metadata$AgeGroups)
head(metadata)
dim(metadata)
return(metadata)
}
# metadata <- makeAgeGroups()
pbmc <- AddMetaData(object = pbmc, metadata = metadata)
# Get rid of any NAs (cells that don't match up with the metadata)
if(subsetCells==F){
pbmc <- FilterCells(object = pbmc,  subset.names = "nGene", low.thresholds = 0)
} else {pbmc <- FilterCells(object = pbmc,  subset.names = "nGene", low.thresholds = 0,
# Subset for testing
cells.use = pbmc@cell.names[0:subsetCells]
)
}
subsetBiotypes <- function(pbmc, subsetGenes){
if( subsetGenes!=F ){
print(paste("Subsetting genes:",subsetGenes))
# If the gene_biotypes file exists, import csv. Otherwise, get from biomaRt
if(file_test("-f", file.path(root,"Data/gene_biotypes.csv"))){
biotypes <- read.csv(file.path(root,"Data/gene_biotypes.csv"))
}
else {
ensembl <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org",
dataset="hsapiens_gene_ensembl")
ensembl <- useDataset(mart = ensembl, dataset = "hsapiens_gene_ensembl")
listFilters(ensembl)
listAttributes(ensembl)
biotypes <- getBM(attributes=c("hgnc_symbol", "gene_biotype"), filters="hgnc_symbol",
values=row.names(pbmc@data), mart=ensembl)
write.csv(biotypes, file.path(root,"Data/gene_biotypes.csv"), quote=F, row.names=F)
}
# Subset data by creating new Seurat object (annoying but necessary)
geneSubset <- biotypes[biotypes$gene_biotype==subsetGenes,"hgnc_symbol"]
print(paste(dim(pbmc@raw.data[geneSubset, ])[1],"/", dim(pbmc@raw.data)[1],
"genes are", subsetGenes))
# Add back into pbmc
subset.matrix <- pbmc@raw.data[geneSubset, ] # Pull the raw expression matrix from the original Seurat object containing only the genes of interest
pbmc_sub <- CreateSeuratObject(subset.matrix) # Create a new Seurat object with just the genes of interest
orig.ident <- row.names(pbmc@meta.data) # Pull the identities from the original Seurat object as a data.frame
pbmc_sub <- AddMetaData(object = pbmc_sub, metadata = pbmc@meta.data) # Add the idents to the meta.data slot
pbmc_sub <- SetAllIdent(object = pbmc_sub, id = "ident") # Assign identities for the new Seurat object
pbmc <- pbmc_sub
rm(list = c("pbmc_sub","geneSubset", "subset.matrix", "orig.ident"))
}
}
subsetBiotypes(pbmc, subsetGenes)
pbmc <- FilterCells(object = pbmc, subset.names = c("nGene", "percent.mito"),
low.thresholds = c(200, -Inf), high.thresholds = c(2500, 0.05))
pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize",
scale.factor = 10000)
# Store the top most variable genes in @var.genes
pbmc <- FindVariableGenes(object = pbmc, mean.function = ExpMean, dispersion.function = LogVMR,
x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5)
# IMPORTANT!: Must set do.par=T and num.cors = n for large datasets being processed on computing clusters
pbmc <- ScaleData(object = pbmc, vars.to.regress = c("nUMI", "percent.mito"), do.par = T, num.cores = nCores)
pbmc
vp <- VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"),nCol = 3, do.return = T) %>% + ggplot2::aes(alpha=0.5)
vp
# par(mfrow = c(1, 2))
gp1 <- GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "percent.mito", pch.use=20,
do.hover=T, data.hover = "mut")
gp1
gp2 <- GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "nGene", pch.use=20,
do.hover=T, data.hover = "mut")
gp2
# Run PCA with only the top most variables genes
pbmc <- RunPCA(object = pbmc, pc.genes = pbmc@var.genes, do.print=F) #, pcs.print = 1:5,  genes.print = 5
VizPCA(object = pbmc, pcs.use = 1:2)
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2, do.hover=T, data.hover="mut")
pbmc <- ProjectPCA(object = pbmc, do.print=F)
# 'PCHeatmap' is a wrapper for heatmap.2
# PCA Heatmap: PC1-PCn
PCHeatmap(object = pbmc, pc.use = 1:12, do.balanced=T, label.columns=F, use.full=F)
#
# PCHeatmap_interactive <- function(PC=1){
#   PC_dat <- PCHeatmap(object = pbmc, pc.use = PC, do.return = T)
#   # Cluster samples
#   Xclust <- pcp %>% dist(upper = T) %>% hclust()
#   Yclust <- PC_dat %>% t() %>% dist(upper = T) %>% hclust()
#   PC_dat <- PC_dat[Xclust$order, Yclust$order]
#   # Plotly
#   plot_ly(y=row.names(PC_dat), z=matrix(PC_dat), type = "heatmap",
#           colors =viridis::plasma(n=100))
# }
# PCHeatmap_interactive(PC=1)
#pbmc <- JackStraw(object = pbmc, num.replicate = 100, display.progress = FALSE)
PCElbowPlot(object = pbmc)
# TRY DIFFERENT RESOLUTIONS
pbmc <- StashIdent(object = pbmc, save.name = "pre_clustering")
# pbmc <- SetAllIdent(object = pbmc, id = "pre_clustering")
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10,
resolution = resolution, print.output = 0, save.SNN = T)
PrintFindClustersParams(object = pbmc)
pbmc <- StashIdent(object = pbmc, save.name = "post_clustering")
pbmc <- RunUMAP(object = pbmc, dims.use = 1:10)
# Plot results
DimPlot(object = pbmc, reduction.use = 'umap')
labSize <- 6
pbmc <- RunTSNE(object=pbmc,  reduction.use = "pca", dims.use = 1:10, do.fast = TRUE,
tsne.method = "Rtsne", num_threads=0) # num_threads
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc, do.label=T, label.size = labSize, do.return=T) %>% ggplotly()
tSNE_metadata_plot <- function(var){
print(paste("t-SNE Metadata plot for ", var))
# Metadata plot
p1 <- TSNEPlot(pbmc, do.return = T,  do.label = T,  group.by = var, pt.size=1,
plot.title=paste("Color by ",var), vector.friendly=T) %>% ggplotly() %>%
layout(legend = list(orientation = 'h', xanchor = "center", x = 0.5, y = .999))
# t-SNE clusters plot
p2 <- TSNEPlot(pbmc, do.return = T, do.label = T, pt.size=1,
plot.title=paste("Color by Clusters"), vector.friendly=T) %>% ggplotly() %>%
layout(legend = list(orientation = 'h', xanchor = "center", x = 0.5, y = .999))
#print(plot_grid(ggplotly(p1), ggplotly(p2)))
fluidPage(
fluidRow(
column(6, p1), column(6, p2)
)
)
}
# metaVars <- c(dx","mut","Gender","Age")
#
# for (var in metaVars){
#   print(paste("t-SNE Metadata plot for ",var))
#   # Metadata plot
#   p1 <- TSNEPlot(pbmc, do.return = T, pt.size = 0.5, group.by = var, do.label = T,
#                  dark.theme=F, plot.title=paste("Color by ",var))
#   # t-SNE clusters plot
#   p2 <- TSNEPlot(pbmc, do.label = T, do.return = T, pt.size = 0.5, plot.title=paste("Color by t-SNE clusters"))
#   print(plot_grid(p1, p2))
# }
tSNE_metadata_plot("dx")
tSNE_metadata_plot("mut")
tSNE_metadata_plot("Gender")
tSNE_metadata_plot("Age")
### Biomarkers: All Clusters vs. All Other Clusters ***
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
topNum = 5
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
topBiomarkers <- pbmc.markers %>% group_by(cluster) %>% top_n(topNum, avg_logFC)
createDT(topBiomarkers, caption = paste("Top",topNum,"Biomarkers: All Clusters"))
getTopBiomarker <- function(pbmc.markers, clusterID, topN=1){
df <-pbmc.markers %>%
subset(p_val_adj<0.05 & cluster==as.character(clusterID)) %>%
arrange(desc(avg_logFC))
top_pct_markers <- df[1:topN,"gene"]
return(top_pct_markers)
}
# clust1_biomarkers <- getTopBiomarker(pbmc.markers, clusterID=1, topN=2)
# clust2_biomarkers <- getTopBiomarker(pbmc.markers, clusterID=2, topN=2)
### Plot biomarkers
plotBiomarkers <- function(pbmc, biomarkers, cluster){
biomarkerPlots <- list()
for (marker in biomarkers){
p <- VlnPlot(object = pbmc, features.plot = c(marker), y.log=T, return.plotlist=T)
biomarkerPlots[[marker]] <- p + ggplot2::aes(alpha=0.5) + xlab( "Cluster") + ylab( "Expression")
}
combinedPlot <- do.call(grid.arrange, c(biomarkerPlots, list(ncol=2, top=paste("Top DEG Biomarkers for Cluster",cluster))) )
# biomarkerPlots <- lapply(biomarkers, function(marker) {
#   VlnPlot(object = pbmc, features.plot = c(marker), y.log=T, return.plotlist=T) %>% + ggplot2::ggtitle(marker) %>% ggplotly()
# })
# return(subplot(biomarkerPlots) )
}
top1 <- pbmc.markers %>% group_by(cluster) %>% top_n(1, avg_logFC)
nCols <- floor( sqrt(length(unique(top1$cluster))) )
figHeight <- nCols *7
# Plot top 2 biomarker genes for each
for (clust in unique(pbmc.markers$cluster)){
cat('\n')
cat("### Cluster ",clust,"\n")
biomarkers <- getTopBiomarker(pbmc.markers, clusterID=clust, topN=2)
plotBiomarkers(pbmc, biomarkers, clust)
cat('\n')
}
getClusterDEGs <- function(pbmc.markers, clusterID){
DF <- pbmc.markers
DF <- subset(DF, clusterID==as.character(clusterID)) %>% arrange(desc(avg_logFC))
return(DF)
}
##Construct the plot object
volcanoPlot <- function(DEG_df, caption="", topFC_labeled=5){
DEG_df$sig<-  ifelse( DEG_df$p_val_adj<0.05 & DEG_df$avg_logFC<1.5, "p_val_adj<0.05",
ifelse( DEG_df$p_val_adj<0.05  & DEG_df$avg_logFC>1.5, "p_val_adj<0.05 & avg_logFC>1.5",
"p_val_adj>0.05"
))
DEG_df <- arrange(DEG_df, desc(sig))
vol <- ggplot(data=DEG_df, aes(x=avg_logFC, y= -log10(p_val_adj))) +
geom_point(alpha=0.5, size=3, aes(col=sig)) +
scale_color_manual(values=list("p_val_adj<0.05"="turquoise3",
"p_val_adj<0.05 & avg_logFC>1.5"="purple",
"p_val_adj>0.05" = "darkgray")) +
theme(legend.position = "none") +
xlab(expression(paste("Average ",log^{2},"(fold change)"))) +
ylab(expression(paste(-log^{10},"(p-value)"))) + xlim(-2,2) +
## ggrepl labels
geom_text_repel(data= arrange(DEG_df, desc(avg_logFC))[1:topFC_labeled,],
# filter(DEG_df, avg_logFC>=1.5)[1:10,],
aes(label=gene),  color="black", alpha=.5,
segment.color="black", segment.alpha=.5
) +
# Lines
geom_vline(xintercept= -1.5,lty=4, lwd=.3, alpha=.5) +
geom_vline(xintercept= 1.5,lty=4, lwd=.3, alpha=.5) +
geom_hline(yintercept= -log10(0.05),lty=4, lwd=.3, alpha=.5) +
ggtitle(caption)
print(vol)
}
for (clust in unique(pbmc.markers$cluster)){
cat('\n')
cat("### Cluster ",clust,"\n")
DEG_df <- getClusterDEGs(pbmc.markers, clust)
volcanoPlot(DEG_df, caption)
createDT(DEG_df, caption = paste("Cluster",clust,"DEG Table"))
cat('\n')
}
fp <- FeaturePlot(object = pbmc, features.plot = top1$gene, cols.use = c("grey", "purple"),
reduction.use = "tsne", nCol = nCols, do.return = T)
top5 <- pbmc.markers %>% group_by(cluster) %>% top_n(5, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = pbmc, genes.use = top5$gene, slim.col.label=T, remove.key=T) %>% ggplotly()
RidgePlot(pbmc, features.plot = top1$gene,  nCol = nCols, do.sort = F)
markerList <- c("CD14", "FCGR3A")
genes_by_cluster <- function(pbmc, markerList){
marker.matrix <- pbmc@scale.data[row.names(pbmc@scale.data) %in% markerList, ]
markerMelt <- reshape2:::melt.matrix(marker.matrix)
colnames(markerMelt) <- c("Gene", "Cell", "Expression")
identData <- data.frame(pbmc@ident)
identData$Cell <- row.names(identData)
colnames(identData) <- c("Cluster","Cell")
markerDF <- merge(markerMelt,  identData, by = "Cell")
return(markerDF)
}
markerDF <- genes_by_cluster(pbmc, markerList)
# Show mean exp for each marker
avgMarker <- markerDF %>% group_by(Gene, Cluster) %>% summarise(meanExp = mean(Expression))
ggplot(data = avgMarker, aes(x=Gene, y=Cluster, fill=meanExp)) %>% + geom_tile() %>% + scale_fill_distiller(palette="viridis") %>% ggplotly()
markerMelt <- reshape2::acast(markerDF, Cell~Gene, value.var="Expression", fun.aggregate = mean, drop = F, fill = 0)
#plot_ly(  z = markerMelt, y=row.names(markerMelt), z=colnames(markerMelt), type="heatmap")
# dx_colors <- colorRampPalette(brewer.pal(2, "RdBu"))
# mut_colors <- colorRampPalette(brewer.pal(length(unique(pbmc@meta.data$mut)), "Set3"))
Spectral <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(length(unique(pbmc@meta.data$mut)), "Spectral"))
# Spectral <- heatmaply::Spectral(length(unique(pbmc@meta.data$mut)))
heatmaply::heatmaply(markerMelt,  key.title="Expression",#plot_method= "plotly",
k_row = length(unique(pbmc.markers)), dendrogram = "row",
showticklabels = c(T, F), xlab = "Known Markers", ylab = "Cells", column_text_angle = 0,
row_side_colors =  pbmc@meta.data[,c("dx","mut")], row_side_palette = Spectral
)  %>%  colorbar(tickfont = list(size = 12), titlefont = list(size = 14), which = 2)  %>%
colorbar(tickfont = list(size = 12), titlefont = list(size = 14), which = 1)
ggplot(data = markerDF, aes(x=Cluster, y=Expression, fill=Gene)) %>%
+ geom_boxplot(alpha=0.5) %>% + scale_fill_manual(values=c("purple", "turquoise")) # %>% ggplotly()
expressionTSNE <- function(pbmc, marker, colors=c("grey", "red")){
FeaturePlot(object = pbmc, features.plot = marker, cols.use = colors,
reduction.use = "tsne", nCol=2, do.return = T, dark.theme = T)[[1]] %>% ggplotly()
}
subplot(expressionTSNE(pbmc, markerList[1]),
expressionTSNE(pbmc, markerList[2],  colors=c("grey", "green")))
current.cluster.ids <- unique(pbmc.markers$cluster) #c(0, 1, 2, 3, 4, 5, 6, 7)
top1 <- pbmc.markers %>% group_by(cluster) %>% top_n(1, avg_logFC)
new.cluster.ids <- top1$gene #c("CD4 T cells", "CD14+ Monocytes", "B cells", "CD8 T cells", "FCGR3A+ Monocytes", "NK cells", "Dendritic cells", "Megakaryocytes")
pbmc@ident <- plyr::mapvalues(x = pbmc@ident, from = current.cluster.ids, to = new.cluster.ids)
TSNEPlot(object=pbmc, do.label=T, pt.size=0.5, do.return=T) %>% ggplotly()
# Available DGE methods:
## "wilcox", "bimod", "roc", "t", "tobit", "poisson", "negbinom", "MAST", "DESeq2"
runDGE <- function(pbmc, meta_var, group1, group2, test.use="wilcox"){
#print(paste("DGE_allCells",meta_var,sep="_"))
pbmc <- SetAllIdent(pbmc, id = meta_var)
pbmc <- StashIdent(pbmc, save.name = meta_var)
DEGs <- FindMarkers(pbmc, ident.1=group1, ident.2=group2, test.use=test.use)
DEGs$gene <- row.names(DEGs)
return(DEGs)
}
df <-runDGE(pbmc, "dx", group1 = "PD", group2="control")
