# library(monocle) # BiocManager::install("monocle")
# paste("monocle", packageVersion("monocle"))
library(monocle3)
paste("monocle3", packageVersion("monocle3"))
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
paste("garnett", packageVersion("garnett"))
library(cowplot)
library(ggplot2)
library(dplyr)
library(data.table)
library(readxl)
library(reshape2)
library(ggrepel)
library(plotly)
library(GeneOverlap) # BiocManager::install("GeneOverlap")
if(getwd()=="/Users/schilder/Desktop/PD_scRNAseq"){
allGenes <- F
test.use <- "wilcox"
}else{
allGenes <- T
# MAST not install on Minerva...
test.use <- "wilcox"}
allGenes <- T
# Make sure Seurat object is up to do date with Seurat v3 format
seurat_object <- Seurat::UpdateSeuratObject(object = DAT)
DAT <- Seurat::SubsetData(object = DAT,  subset.names = "nGene", low.thresholds = 0)
DAT
DAT@meta.data
DAT@meta.data$nGene
is.na(DAT@meta.data$nGene)
DAT@meta.data[is.na,]
DAT@meta.data[is.na(DAT@meta.data$nGene),]
DAT@meta.data[!is.na(DAT@meta.data$nGene),]
DAT@meta.data  <- DAT@meta.data[!is.na(DAT@meta.data$nGene),]
DAT
fDATA <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
# Make sure metadata and expression data have the same cells
cell_IDs <- dplyr::intersect(colnames(data), row.names(metadata))
data <- data[,cell_IDs]
data
sDAT <- seurat_object@raw.data
print("+ Phenotype data")
metadata <- as.data.frame(seurat_object@meta.data)
# Filter metadata
DAT <- Seurat::SubsetData(object = sDAT,  subset.names = "nGene", low.thresholds = 0)
# Filter metadata
sDAT@meta.data  <- sDAT@meta.data[!is.na(sDAT@meta.data$nGene),]
sDAT
# Make sure Seurat object is up to do date with Seurat v3 format
sDAT <- Seurat::UpdateSeuratObject(object = DAT)
sDAT <- seurat_object@raw.data
dat <- sDAT@raw.data
# Make sure Seurat object is up to do date with Seurat v3 format
sDAT <- Seurat::UpdateSeuratObject(object = DAT)
dat <- sDAT@raw.data
print("+ Phenotype data")
metadata <- as.data.frame(seurat_object@meta.data)
# Filter metadata
dat@meta.data  <- dat@meta.data[!is.na(dat@meta.data$nGene),]
expr_dat <- sDAT@raw.data
print("+ Phenotype data")
metadata <- as.data.frame(seurat_object@meta.data)
# Filter metadata
sDAT@meta.data  <- sDAT@meta.data[!is.na(sDAT@meta.data$nGene),]
fDATA <- data.frame(gene_short_name = row.names(expr_dat), row.names = row.names(expr_dat))
metadata <- as.data.frame(sDAT@meta.data)
metadata <- sDAT@meta.data
fDATA <- data.frame(gene_short_name = row.names(expr_dat), row.names = row.names(expr_dat))
# Make sure metadata and expression data have the same cells
cell_IDs <- dplyr::intersect(colnames(expr_dat), row.names(metadata))
sDAT <- sDAT[,cell_IDs]
sDAT
cell_IDs
expr_dat <- expr_dat[,cell_IDs]
metadata <- metadata[cell_IDs,]
print("Expression Data dims:")
print(dim(expr_dat))
print("Metadata dims:")
print(dim(metadata))
print("Feature Data dims:")
print(dim(fDATA))
cds <- monocle3::new_cell_data_set(expression_data = expr_dat,
cell_metadata = metadata,
gene_metadata = fDATA)
cds
metadata
seurat_to_monocle <- function(seurat_object, monocle_version=3){
# Make sure Seurat object is up to do date with Seurat v3 format
sDAT <- Seurat::UpdateSeuratObject(object = DAT)
# From: https://github.com/cole-trapnell-lab/monocle-release/issues/262
print("Processing...")
print("+ Expression data")
expr_dat <- sDAT@raw.data
print("+ Phenotype data")
# Filter metadata
sDAT@meta.data  <- sDAT@meta.data[!is.na(sDAT@meta.data$nGene),]
metadata <- sDAT@meta.data
print("+ Feature Data")
fDATA <- data.frame(gene_short_name = row.names(expr_dat), row.names = row.names(expr_dat))
# Make sure metadata and expression data have the same cells
cell_IDs <- dplyr::intersect(colnames(expr_dat), row.names(metadata))
expr_dat <- expr_dat[,cell_IDs]
metadata <- metadata[cell_IDs,]
print("Expression Data dims:")
print(dim(expr_dat))
print("Metadata dims:")
print(dim(metadata))
print("Feature Data dims:")
print(dim(fDATA))
#Construct monocle cds
if(monocle_version==3){
print("+ Converting to monocle (Version 3)")
cds <- monocle3::new_cell_data_set(expression_data = expr_dat,
cell_metadata = metadata,
gene_metadata = fDATA)
} else {
print("+ Converting to monocle (Version 2)")
pd <- new('AnnotatedDataFrame', data = seurat_object@meta.data)
fd <- new('AnnotatedDataFrame', data = fDATA)
cds <- monocle::newCellDataSet(data,
phenoData = pd,
featureData = fd,
lowerDetectionLimit = 0.5,
expressionFamily = VGAM::negbinomial.size())
}
return(cds)
}
cds <- seurat_to_monocle(seurat_object = DAT, monocle_version = 3)
cds <- preprocess_cds(cds,
num_dim = 100,
residual_model_formula_str = "~ nUMI + percent.mito")
cds
# c("UMAP", "tSNE", "PCA", "LSI")
cds <- reduce_dimension(cds, reduction_method = "UMAP")
nCores
nCores <- parallel::detectCores()
nCores
# c("UMAP", "tSNE", "PCA", "LSI")
cds <- reduce_dimension(cds, reduction_method = "UMAP",
max_components = 3,
cores=nCores)
cds
?cluster_cells
cds <- cluster_cells(cds, resolution=NULL)
cds <- cluster_cells(cds, resolution=NULL)
cds
cds@clusters
cds@clusters@metadata
str(cds@clusters)
cds@clusters@listData
cds@clusters@elementType
cds@clusters@elementMetadata
cds@clusters@listData$UMAP$partitions
cds@clusters@listData$UMAP$clusters
cds <- cluster_cells(cds, resolution=NULL, reduction_method = "UMAP")
cds <- learn_graph(cds)
cds <- order_cells(cds)
plot_cells(cds)
cds <- cluster_cells(cds, resolution=1e-04, reduction_method = "UMAP")
monocle3::plot_cells_3d(cds)
monocle3::plot_cells(cds)
monocle3::plot_genes_in_pseudotime(cds)
monocle3::plot_pc_variance_explained(cds)
monocle3::plot_pc_variance_explained(cds)
monocle3::plot_cells_3d(cds)
pData(dcs)
pData(cds)
start_time <- Sys.time()
# Import functions
root = "./"
source(file.path(root,"MAIN.R"))
import_parameters(params)
# load("Results/Current_Pipeline/scRNAseq_results.RData")
load(file.path(resultsPath, "scRNAseq_results.RData"))
# resultsPath <- "Results/subsetGenes-protein_coding__subsetCells-F__Resolution-0.2__perplexity-40__nCores-4"
print("Written using: Seurat version* 2.3.4 2018-07-17")
# https://satijalab.org/seurat/install.html
library(Seurat) #
paste("Seurat", packageVersion("Seurat"))
# library(monocle) # BiocManager::install("monocle")
# paste("monocle", packageVersion("monocle"))
library(monocle3)
paste("monocle3", packageVersion("monocle3"))
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
paste("garnett", packageVersion("garnett"))
library(cowplot)
library(ggplot2)
library(dplyr)
library(data.table)
library(readxl)
library(reshape2)
library(ggrepel)
library(plotly)
library(GeneOverlap) # BiocManager::install("GeneOverlap")
if(getwd()=="/Users/schilder/Desktop/PD_scRNAseq"){
allGenes <- F
test.use <- "wilcox"
}else{
allGenes <- T
# MAST not install on Minerva...
test.use <- "wilcox"}
allGenes <- T
nCores <- parallel::detectCores()
set.seed(2019)
biotypes <- get_biotypes(DAT)
proteins <- biotypes[biotypes$gene_biotype=="protein_coding",]$hgnc_symbol %>% droplevels()
protDAT <- subset_seurat(DAT, genes.use = proteins)
cds <- seurat_to_monocle(seurat_object = DAT, monocle_version = 3)
cds <- cds[levels(proteins),]
cds <- monocle3::preprocess_cds(cds,
num_dim = 20, #100 by default
residual_model_formula_str = "~ nUMI + percent.mito")
monocle3::plot_pc_variance_explained(cds)
# c("UMAP", "tSNE", "PCA", "LSI")
cds <- monocle3::reduce_dimension(cds, reduction_method = "UMAP",
max_components = 3
# umap.fast_sgd = T,
# cores=nCores
)
# Method 1
# variable.genes <- cds@preprocess_aux@listData$gene_loadings[,1:3] %>%
#   abs() %>% rowSums() %>% base::sort(decreasing = T)
# head(variable.genes)
varDAT <- FindVariableGenes(object = protDAT,
mean.function = ExpMean,
dispersion.function = LogVMR,
selection.method ="dispersion", do.plot = T,
top.genes = 2000)
var.genes <- varDAT@var.genes
head(var.genes)
cds <- monocle3::cluster_cells(cds,
resolution = 1e-4,#c(10^seq(-6,-1)), # Do NOT set to high number
reduction_method = "UMAP",
cores = nCores,
clustering_genes = var.genes)
plot_cells_3d(cds, color_cells_by = "cluster", show_trajectory_graph = F)
plot_cells(cds, color_cells_by = "partition", group_cells_by="partition", show_trajectory_graph = F)
## Extract cluster info
# monocle3::clusters(cds)
# monocle3::partitions(cds)
# Learn
cds <- monocle3::learn_graph(cds)
# Order cells
root_pr_nodes = get_earliest_principal_node(cds, variable = "dx", variable_value = "PD")
cds <- monocle3::order_cells(cds, root_pr_nodes = root_pr_nodes)
monocle3::plot_cells(cds)
dge.dx <- monocle3_DGE(cds[var.genes[1:100],], "dx", nCores = nCores)
dge <-dge.dx
# dge <-dge.dx
dge.dx
# dge <-dge.dx
data.table(dge.dx)
marker_test_res = top_markers(cds[var.genes[1:100], ],
group_cells_by="cluster",
reference_cells=1000,
cores=nCores)
# Cluster-specific markers
top_specific_markers = marker_test_res %>%
filter(fraction_expressing >= 0.10) %>%
group_by(cell_group) %>%
top_n(4, pseudo_R2)
top_specific_marker_ids = unique(top_specific_markers %>% pull(gene_id))
# monocle3::plot_genes_by_group(cds,
#                               markers=top_specific_marker_ids,
#                               group_cells_by="partition",
#                               ordering_type="maximal_on_diag",
#                               max.size=3)
data.table::data.table(top_specific_markers)
library(org.Hs.eg.db)
columns(org.Hs.eg.db)
load(url("https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC"))
cds = garnett::classify_cells(cds,
hsPBMC,
db = org.Hs.eg.db,
cluster_extend = T,
cds_gene_id_type = "SYMBOL")
plot_cells(cds,
group_cells_by="cluster",
color_cells_by="cluster_ext_type",  # cell_type
show_trajectory_graph = F )
getearl
pr_graph_test_res = monocle3::graph_test(cds, neighbor_graph="knn", cores=nCores)
gene_module_df = find_gene_modules(cds[var.genes[1:100]], resolution=1e-2, cores = nCores)
gene_module_df = find_gene_modules(cds[var.genes[1:100],], resolution=1e-2, cores = nCores)
var.genes[1:100]
gene_module_df
gene_module_df$module %>% unique()
gene_module_df = find_gene_modules(cds, resolution=1e-2, cores = nCores)
cds[var.genes[1:100]]
gene_module_df = find_gene_modules(cds[var.genes[1:1000],], resolution=1e-2, cores = nCores)
gene_module_df
cell_group_df = tibble::tibble(cell=row.names(colData(cds)),
cell_group=partitions(cds)[colnames(cds)])
cell_group_df
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
agg_mat
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) = stringr::str_c("Partition ", colnames(agg_mat))
pheatmap::pheatmap(agg_mat, cluster_rows=TRUE, cluster_cols=TRUE,
scale="column", clustering_method="ward.D2",
fontsize=6)
cell_group_df = tibble::tibble(cell=row.names(colData(cds)),
cell_group=clusters(cds)[colnames(cds)])
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) = stringr::str_c("Clusters ", colnames(agg_mat))
pheatmap::pheatmap(agg_mat, cluster_rows=TRUE, cluster_cols=TRUE,
scale="column", clustering_method="ward.D2",
fontsize=6)
colnames(agg_mat) = stringr::str_c("Cluster ", colnames(agg_mat))
pheatmap::pheatmap(agg_mat, cluster_rows=TRUE, cluster_cols=TRUE,
scale="column", clustering_method="ward.D2",
fontsize=6)
cell_group_df = tibble::tibble(cell=row.names(colData(cds)),
cell_group=clusters(cds)[colnames(cds)])
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) = stringr::str_c("Cluster", colnames(agg_mat))
pheatmap::pheatmap(agg_mat, cluster_rows=TRUE, cluster_cols=TRUE,
scale="column", clustering_method="ward.D2",
fontsize=6)
?find_gene_modules
plot_cells(cds,
genes=gene_module_df %>% filter(module %in% c(16,38,33,42)),
group_cells_by="partition",
color_cells_by="partition",
show_trajectory_graph=FALSE)
gene_module_df %>% filter(module %in% c(16,38,33,42))
gene_module_df
gene_module_df %>% filter(module %in% c(1:3))
plot_cells(cds,
genes=gene_module_df %>% filter(module %in% c(1:3)),
group_cells_by="partition",
color_cells_by="partition",
show_trajectory_graph=FALSE)
plot_cells(cds,
genes=gene_module_df,
group_cells_by="cluster",
color_cells_by="cluster",
show_trajectory_graph=F)
plot_cells(cds,
genes=gene_module_df,
group_cells_by="cluster",
color_cells_by="cluster",
show_trajectory_graph=F, rasterize = T)
plot_cells(cds,
genes=gene_module_df,
group_cells_by="cluster",
color_cells_by="cluster",
show_trajectory_graph=F) #  rasterize = T (for super high-res figures)
?plot_cells_3d
monocle3::plot_genes_in_pseudotime(cds[c("CD14","FCGR3A")] )
monocle3::plot_genes_in_pseudotime(cds[c("CD14","FCGR3A"), ] )
plot_cells_3d(cds, color_cells_by = "cluster", show_trajectory_graph = F)
p3d <- plot_cells_3d(cds, color_cells_by = "cluster", show_trajectory_graph = F)
p3d
rgl::writeOBJ(p3d)
p3d
str(p3d)
p3d$x
hook_webgl
# Exporting 3D plots
knitr::knit_hooks$set(webgl = rgl::hook_webgl)
# Method 1
# variable.genes <- cds@preprocess_aux@listData$gene_loadings[,1:3] %>%
#   abs() %>% rowSums() %>% base::sort(decreasing = T)
# head(variable.genes)
varDAT <- Seurat::FindVariableGenes(object = protDAT,
mean.function = ExpMean,
dispersion.function = LogVMR,
selection.method ="dispersion", do.plot = T,
top.genes = 2000)
open3d()
library(rgl)
open3d()
shade3d(readOBJ(url(
"http://sci.esa.int/science-e/www/object/doc.cfm?fobjectid=54726"
), material = list(col = "gray")))
shade3d(readOBJ(p3d, material = list(col = "gray")))
shade3d( p3d)
library(rgl)
open3d()
p3d
writeOBJ()
open3d()
p3d
p3d
# writeOBJ()
# rgl.postscript("persp3dd.pdf","pdf")
rglwidgetOutput()
plot3d(p3d)
plot3d(p3d$x)
plot3d(p3d$preRenderHook())
p3d$preRenderHook()
p3d
writeOBJ(dir="./webGL")
writeOBJ(con = "./webGL")
writeOBJ(con = "./webGL.obj")
library(rgl)
p3d
writeOBJ(con = "./webGL.obj")
rgl.snapshot
?rgl.snapshot
p3d$jsHooks
p3d$width
p3d$sizingPolicy
p3d$elementId
p3d$preRenderHook()
p3d$x
plot3d(p3d$x)
plot3d(p3d$x$visdat)
p3d$x$visdat
plot3d(p3d)
chart_link = api_create(p3d, filename="webgl-timeSeries")
p3d
?plotly::export
?plotlyOutput
?saveWidget
plotly::plotlyOutput()
plotly::renderPlotly(p3d)
rgl::writeOBJ(p3d)
p3d
htmlwidgets::shinyRenderWidget(p3d)
rgl::writeOBJ(con = "./webGL.obj")
cds@reducedDims
cds@reducedDims$UMAP
cds@reducedDims$UMAP[1,]
cds@reducedDims$UMAP[,1]
plot3d(x = cds@reducedDims$UMAP[,1],
y = cds@reducedDims$UMAP[,2],
z = cds@reducedDims$UMAP[,3]  )
rgl::plot3d(x = cds@reducedDims$UMAP[,1],
y = cds@reducedDims$UMAP[,2],
z = cds@reducedDims$UMAP[,3]  )
rgl::writeOBJ(con = "./webGL.obj")
DT::datatable(top_specific_markers)
cds@clusters
unique(GetClusters(cds))
cds
clusters(cds)
unique(clusters(cds))
cds@clusters$UMAP$clusters
levels(clusters(cds))
clust=1
clusters(cds)==clust
cds[,clusters(cds)==clust]
cds_sub <- cds[,clusters(cds)==clust]
save_3D_clusters <- function(cds){
for(clust in levels(clusters(cds)) ){
cds_sub <- cds[,clusters(cds)==clust]
rgl::plot3d(x = cds@reducedDims$UMAP[,1],
y = cds@reducedDims$UMAP[,2],
z = cds@reducedDims$UMAP[,3]  )
rgl::writeOBJ(con = paste0("./cluster",clust,".obj") )
}
}
save_3D_clusters <- function(cds){
for(clust in levels(clusters(cds)) ){
print(paste0("Creating OBJ for cluster ",clust))
cds_sub <- cds[,clusters(cds)==clust]
rgl::plot3d(x = cds@reducedDims$UMAP[,1],
y = cds@reducedDims$UMAP[,2],
z = cds@reducedDims$UMAP[,3]  )
rgl::writeOBJ(con = paste0("./cluster",clust,".obj") )
}
}
save_3D_clusters(cds)
clusters(cds)==clust
cds_sub <- cds[,clusters(cds)==clust]
cds_sub
cds
save_3D_clusters <- function(cds){
for(clust in levels(clusters(cds)) ){
print(paste0("Creating OBJ for cluster ",clust))
cds_sub <- cds[,clusters(cds)==clust]
rgl::plot3d(x = cds_sub@reducedDims$UMAP[,1],
y = cds_sub@reducedDims$UMAP[,2],
z = cds_sub@reducedDims$UMAP[,3]  )
rgl::writeOBJ(con = paste0("./cluster",clust,".obj") )
}
}
save_3D_clusters(cds)
?plot3d
rgl::plot3d(x = cds_sub@reducedDims$UMAP[,1],
y = cds_sub@reducedDims$UMAP[,2],
z = cds_sub@reducedDims$UMAP[,3],
box=F)
rgl::plot3d(x = cds_sub@reducedDims$UMAP[,1],
y = cds_sub@reducedDims$UMAP[,2],
z = cds_sub@reducedDims$UMAP[,3],
box=F, axes=F)
rgl::plot3d(x = cds_sub@reducedDims$UMAP[,1],
y = cds_sub@reducedDims$UMAP[,2],
z = cds_sub@reducedDims$UMAP[,3],
box=T, axes=F)
save_3D_clusters <- function(cds){
for(clust in levels(clusters(cds)) ){
print(paste0("Creating OBJ for cluster ",clust))
cds_sub <- cds[,clusters(cds)==clust]
rgl::plot3d(x = cds_sub@reducedDims$UMAP[,1],
y = cds_sub@reducedDims$UMAP[,2],
z = cds_sub@reducedDims$UMAP[,3],
box=F, axes=F)
rgl::writeOBJ(con = paste0("./cluster",clust,".obj"),  )
}
}
save_3D_clusters(cds)
dir.create(output_path, showWarnings = F, recursive = T)
output_path="./3D_objects"
dir.create(output_path, showWarnings = F, recursive = T)
