---
title: "run_seurat"
author: "Brian M. Schilder"
date: "12/26/2018"
output: 
  html_document:
    toc: yes
---

# Parkinson's Disease -Omics: scRNA-seq of Monocytes

<<<<<<< HEAD
## Setup
```{r setup, include=F} 
## Automatically generates rmarkdown output file
knitr::opts_chunk$set(echo=T, error=T, cache=T)
```

### Load Libraries & Report Versions
```{r}
library(Seurat)
library(dplyr)
library(gridExtra)  

sessionInfo()
print(paste("Seurat ", packageVersion("Seurat")))
```


### Load Data
```{r Load Data }   
#setwd("~/Desktop/PD_scRNAseq/")
dir.create(file.path("Data"), showWarnings = FALSE) 
load("Data/seurat_object_add_HTO_ids.Rdata")
pbmc <- seurat.obj  
str(pbmc@raw.data)
```

### Clean Metadata
```{r Clean Metadata , eval=F}
library(readxl)

## Update dx and mut fields
### Import updated  dx, mut info
subjectInfo <- read_excel("Data/scRNAseq_meta.xlsx") 
### Import metadata
meta <- read.table("Data/meta.data3.tsv", header=T )
### Remove last 2 cols (contain incorrect values) and duplicate HTO col
sum(meta$HTO != meta$HTO.1) # double check they're identical

meta["barcode"] = row.names(meta)
unique(meta["HTO"])
# Map incorrect subject IDs to CORRECT subject IDs (typos occurred at NYGC during processing)
map = setNames( # Incorrect (from NYGC)
               c("NYUMD0011", "BIMD0076", "MSMD0067", "BIMD0077", "BIMD0007",
                 "BIMD0075", "NYUMD0015", "MSMD0035","MSMD0207", "BIMD0010"), 
               # Correct (from Evan)
              c("NYUMD0011", "BID0076", "MSMD0067", "BID0077", "BIMD0007",
                 "BID00075","NYUMD0015", "MSMD0035", "MSMD0207", "BIMD0010")
              )
meta["ID"] <- map[unlist(meta["HTO"])]
meta <- subset(meta, select = -c(dx, mut, HTO, HTO.1)) 
### Merge new cols
metadata <- merge(meta, subjectInfo, by="ID", all.x=T) 
row.names(metadata) <- metadata$barcode
colnames(metadata)[colnames(metadata)=="Ethnitcity"] <- "Ethnicity" 

dim(meta)
dim(metadata)
head(metadata)
# Correct misspelling
### Export updated Metadata
write.table(metadata, "Data/meta.data4.tsv") 

# Add metadata to seurat object
pbmc <- AddMetaData(object = pbmc, metadata =  metadata ) 
pbmc
## % Mitochondrial genes metadata
#mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
#percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
#pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
```


### Subset for Testing
```{r Subset for Testing }  
metadata <- read.table("Data/meta.data4.tsv")  
head(metadata)
# Make AgeGroups
makeAgeGroups <- function(){
  dim(metadata)
  getMaxRound <- function(vals=metadata$Age, unit=10)unit*ceiling((max(vals)/unit))
  getMinRound <- function(vals=metadata$Age, unit=10)unit*floor((min(vals)/unit)) 
   
  ageBreaks = c(seq(getMinRound(), getMaxRound(), by = 10), getMaxRound()+10)
  AgeGroupsUniq <- c()
  for (i in 1:(length(ageBreaks)-1)){ 
    AgeGroupsUniq <- append(AgeGroupsUniq, paste(ageBreaks[i],ageBreaks[i+1], sep="-")) 
  } 
  data.table::setDT(metadata,keep.rownames = T,check.names = F)[, AgeGroups := cut(Age, 
                                  breaks = ageBreaks, 
                                  right = F, 
                                  labels = AgeGroupsUniq,
                                  nclude.lowest=T)]
  metadata <- data.frame(metadata)
  unique(metadata$AgeGroups)
  head(metadata)
  dim(metadata)
  return(metadata)
}
# metadata <- makeAgeGroups()

pbmc <- AddMetaData(object = pbmc, metadata = metadata)  
# Get rid of any NAs (cells that don't match up with the metadata)
pbmc <- FilterCells(object = pbmc,  subset.names = "nGene", low.thresholds = 0,
                    # Subset for testing 
                    #cells.use = pbmc@cell.names[0:2000] 
                    )
head(pbmc@meta.data) 
```

## Diagnostic Plots

### Violin Plots
```{r Violin Plots } 
VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
```

### Gene Plots
```{r Gene Plots } 
par(mfrow = c(1, 2))
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "nGene")
```

## Filter & Normalize Data
```{r Filter & Normalize Data }
pbmc <- FilterCells(object = pbmc, subset.names = c("nGene", "percent.mito"), 
    low.thresholds = c(200, -Inf), high.thresholds = c(2500, 0.05))

pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", 
    scale.factor = 10000)

# Store the top most variable genes in @var.genes
pbmc <- FindVariableGenes(object = pbmc, mean.function = ExpMean, dispersion.function = LogVMR,
    x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5)
pbmc <- ScaleData(object = pbmc, vars.to.regress = c("nUMI", "percent.mito"))
```

## Dimensionality Reduction & Clustering

### PCA
ProjectPCA scores each gene in the dataset (including genes not included
in the PCA) based on their correlation with the calculated components.
Though we don't use this further here, it can be used to identify markers
that are strongly correlated with cellular heterogeneity, but may not have
passed through variable gene selection.  The results of the projected PCA
can be explored by setting use.full=T in the functions above
```{r PCA }
# Run PCA with only the top most variables genes
pbmc <- RunPCA(object = pbmc, pc.genes = pbmc@var.genes, do.print = TRUE, pcs.print = 1:5, 
    genes.print = 5)

# PCA plots
VizPCA(object = pbmc, pcs.use = 1:2)
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2)

pbmc <- ProjectPCA(object = pbmc, do.print = FALSE)

## PCA Heatmap: PC1
PCHeatmap(object = pbmc, pc.use = 1, cells.use = 500, do.balanced = TRUE, label.columns = FALSE)
## PCA Heatmap: PC1-PCn
PCHeatmap(object = pbmc, pc.use = 1:12, cells.use = 500, do.balanced = TRUE, 
    label.columns = FALSE, use.full = FALSE)
```

### Determine statistically significant PCs
NOTE: This process can take a long time for big datasets, comment out for
expediency.  More approximate techniques such as those implemented in
PCElbowPlot() can be used to reduce computation time
```{r Determine statistically significant PCs }
#pbmc <- JackStraw(object = pbmc, num.replicate = 100, display.progress = FALSE)
PCElbowPlot(object = pbmc)
```

### Cluster cells
We first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). To cluster the cells, we apply modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function.
```{r Cluster cells } 
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10, 
    resolution = 0.6, print.output = 0, save.SNN = F) 
PrintFindClustersParams(object = pbmc) 
```


### t-SNE
As input to the tSNE, we suggest using the same PCs as input to the clustering analysis, although computing the tSNE based on scaled gene expression is also supported using the genes.use argument.
```{r t-SNE } 
labSize <- 6
pbmc <- StashIdent(object = pbmc, save.name = "pre_clustering") 
#pbmc <- SetAllIdent(object = pbmc, id = "pre_clustering") 


pbmc <- RunTSNE(object = pbmc, dims.use = 1:10, do.fast = TRUE)
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc, do.label=T, label.size = labSize) 
```

### t-SNE + Metadata

```{r t-SNE + Metadata}
metaVars <- c("CellType","dx","mut","Gender","Age")

for (var in metaVars){
  print(paste("t-SNE Metadata plot for ",var))
  # Metadata plot 
  p1 <- TSNEPlot(pbmc, do.return = T, pt.size = 0.5, group.by = var, do.label = T, 
                 dark.theme=F, plot.title=paste("Color by ",var))
  # t-SNE clusters plot
  p2 <- TSNEPlot(pbmc, do.label = T, do.return = T, pt.size = 0.5, plot.title=paste("Color by t-SNE clusters"))
  print(plot_grid(p1, p2))
}   
```


## Finding differentially expressed genes (cluster biomarkers) 

### Biomarkers: All Clusters vs. All Other Clusters ***
```{r cluster biomarkers 3 }
### Biomarkers: One Cluster vs. Specific Clusters
# cluster5.markers <- FindMarkers(object = pbmc, ident.1 = 0, ident.2 = c(2), 
#     min.pct = 0.25)
# print(x = head(x = cluster5.markers, n = 3)) 

### Biomarkers: One Cluster vs. All Other Clusters 
# find all markers of a given cluster
# MUST run FindClusters() first
# cluster0.markers <- FindMarkers(object = pbmc, ident.1 = 0, min.pct = 0.25)
# print(x = head(x = cluster0.markers, n = 3))   


# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
topBiomarkers <- pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
```

### Cluster Biomarker Tests
Seurat has several tests for differential expression which can be set with the test.use parameter (see the DE vignette for details). For example, the ROC test returns the ‘classification power’ for any individual marker (ranging from 0 - random, to 1 - perfect).
```{r cluster biomarkers 4 }
getTopBiomarker <- function(pbmc.markers, clusterID, topN=1){
  df <- subset(pbmc.markers, p_val_adj<0.05 & cluster==as.character(clusterID)) %>% arrange(desc(avg_logFC))
  top_pct_markers <- df[1:topN,"gene"]
  return(top_pct_markers)
}
clust1_biomarkers <- getTopBiomarker(pbmc.markers, clusterID=1, topN=2)
clust2_biomarkers <- getTopBiomarker(pbmc.markers, clusterID=2, topN=2)




# Top Biomarkers for 
plotBiomarkers <- function(pbmc, biomarkers, cluster){
  biomarkerPlots <- list()
  for (marker in biomarkers){
    print(marker)
    p <- VlnPlot(object = pbmc, features.plot = c(marker), y.log=T, return.plotlist=T)
    biomarkerPlots[[marker]] <- p + ggplot2::aes(alpha=.7) 
  }
  combinedPlot <- do.call(grid.arrange, c(biomarkerPlots, 
                                          list(ncol=2, top=paste("Top DEG Biomarkers for Cluster",cluster))) ) 
  return(combinedPlot) 
}

# Plot top 2 biomarker genes for each 
for (clust in unique(pbmc.markers$cluster)){ 
  biomarkers <- getTopBiomarker(pbmc.markers, clusterID=clust, topN=2)
  plotBiomarkers(pbmc, biomarkers, clust)
} 
```

### Top Biomarkers: tSNE
```{r Top biomarkers: tSNE }
FeaturePlot(object = pbmc, features.plot = topBiomarkers$gene, cols.use = c("grey", "blue"), 
    reduction.use = "tsne")
```

## Top Biomarkers: Heatmap
```{r Top biomarkers: Heatmap }
top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(10, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = pbmc, genes.use = top10$gene, slim.col.label = TRUE, remove.key = TRUE)
```

## Assigning cell type identity to clusters

### Label Clusters by Biomarker 
```{r Assign Identity: By Biomarker }
current.cluster.ids <- unique(pbmc.markers$cluster) #c(0, 1, 2, 3, 4, 5, 6, 7)
top1 <- pbmc.markers %>% group_by(cluster) %>% top_n(1, avg_logFC)
new.cluster.ids <- top1$gene #c("CD4 T cells", "CD14+ Monocytes", "B cells", "CD8 T cells", "FCGR3A+ Monocytes", "NK cells", "Dendritic cells", "Megakaryocytes")

pbmc@ident <- plyr::mapvalues(x = pbmc@ident, from = current.cluster.ids, to = new.cluster.ids)
TSNEPlot(object = pbmc, do.label = TRUE, pt.size = 0.5) 
```

## Further subdivisions within cell types
If you perturb some of our parameter choices above (for example, setting resolution=0.8 or changing the number of PCs), you might see the CD4 T cells subdivide into two groups. You can explore this subdivision to find markers separating the two T cell subsets. However, before reclustering (which will overwrite object@ident), we can stash our renamed identities to be easily recovered later.
```{r Assign Identity: By Sub-cell types }
# First lets stash our identities for later
pbmc <- StashIdent(object = pbmc, save.name = "ClusterNames_0.6")

# Note that if you set save.snn=T above, you don't need to recalculate the
# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10, 
    resolution = 0.8, print.output = FALSE)

## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type
## = reduction.type, : Build parameters exactly match those of already
## computed and stored SNN. To force recalculation, set force.recalc to TRUE.

# Demonstration of how to plot two tSNE plots side by side, and how to color
# points based on different criteria
plot1 <- TSNEPlot(object = pbmc, do.return = TRUE, no.legend = TRUE, do.label = TRUE, label.size=labSize)
plot2 <- TSNEPlot(object = pbmc, do.return = TRUE, group.by = "ClusterNames_0.6", 
                  no.legend = TRUE, do.label = TRUE, label.size=labSize)
plot_grid(plot1, plot2)


# Find discriminating markers
tcell.markers <- FindMarkers(object = pbmc, ident.1 = 0, ident.2 = 1)

# Most of the markers tend to be expressed in C1 (i.e. S100A4). However, we
# can see that CCR7 is upregulated in C0, strongly indicating that we can
# differentiate memory from naive CD4 cells.  cols.use demarcates the color
# palette from low to high expression
FeaturePlot(object = pbmc, features.plot = top1$gene, cols.use = c("green", "blue"))

pbmc <- SetAllIdent(object = pbmc, id = "ClusterNames_0.6") 
```

## Save Results
```{r Save Results}
saveRDS(pbmc, file = "Data/cd14-processed.rds") 
```


