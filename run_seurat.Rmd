---  
title: "Parkinson's Disease scRNA-seq: CD14++ Monocytes" 
author: |
  | Brian M. Schilder, Bioinformatician II
  | Raj Lab
  | Department of Neuroscience
  | Icahn School of Medicine at Mount Sinai
  | NYC, New York
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_document: 
    theme: spacelab
    highlight: zenburn 
    code_folding: show 
    toc: true 
    toc_float: true
    smooth_scroll: true
    number_sections: false 
    self_contained: true  
params:
  subsetGenes: "protein_coding" #FALSE
  subsetCells: 500 #FALSE
  resolution: 0.6
  resultsPath: "./"
  nCores: 2
  perplexity: 30
---
 

# Setup 

```{r setup,  dpi = 600}
resultsPath=file.path(getwd(),"Results")
# Gather parameters from command line  
#dir.create(file.path(resultsPath,"cache"), showWarnings=F, recursive=T)
nCores <- params$nCores #parallel::detectCores()
subsetGenes <- params$subsetGenes 
subsetCells <- params$subsetCells 
resolution <-  as.numeric(params$resolution)
interactive <- params$interactive
perplexity <- params$perplexity 

perplexity <- ifelse(exists("perplexity"), perplexity, 30)

root <- getwd()
# Have to setwd via knitr
# knitr::opts_knit$set(root.dir=resultsPath, child.path = resultsPath)
knitr::opts_chunk$set(echo=T, error=T, root.dir = resultsPath 
                      # cache=T, cache.lazy=T
                      ) 
 
# Utilize parallel processing later on
cat(paste("**** __Utilized Cores__ **** =", nCores))   

params
```

__`r params$resultsPath`__
 
 
## Load Libraries & Report Versions

```{r Load Libraries & Report Versions, message=F, warning=F}
library(Seurat)
library(dplyr)
library(gridExtra)
library(knitr) 
library(plotly)
library(ggplot2)
library(viridis)
library(reshape2)
library(shiny) 
library(ggrepel)
library(DT) 
library(ComplexHeatmap); #BiocManager::install("ComplexHeatmap") 
  
## Install Bioconductor
#  if (!requireNamespace("BiocManager"))
#     install.packages("BiocManager") 
library(biomaRt) # BiocManager::install(c("biomaRt"))
library(DESeq2) # BiocManager::install(c("DESeq2"))
library(enrichR) #BiocManager::install("enrichR")

library(monocle) #BiocManager::install("monocle")
# BiocManager::install("DelayedMatrixStats")
# BiocManager::install("org.Mm.eg.db") 
library(org.Hs.eg.db)
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")

# Useful Seurat functions 
## Seurat::MultiModal_CCA() # Integrates data from disparate datasets (CIA version too) 

sessionInfo()
print(paste("Seurat ", packageVersion("Seurat")))
```

## Helper Functions 
```{r Helper Functions, results='asis'}
createDT <- function(DF, caption="", scrollY=500){
  data <- DT::datatable(DF, caption=caption,
    extensions =  'Buttons',
    options = list( dom = 'Bfrtip', 
                    buttons = c('copy', 'csv', 'excel', 'pdf', 'print'), 
                    scrollY = scrollY, scrollX=T, scrollCollapse = T, paging = F,  
                      columnDefs = list(list(className = 'dt-center', targets = "_all"))
    )
  ) 
   return(data)
}
# Need to wrap inside tagList when rendering DTs within a for loop
createDT_html <- function(DF, caption="", scrollY=400){
  print( htmltools::tagList( createDT(DF, caption, scrollY)) ) 
}
```


## Raise Memory Limit

Rstudio has a default memory limit of only 1GB. To override this, detect the true memory available and set a new limit.
```{r Raise Memory Limit, eval=F}
library(ulimit) # devtools::install_github("krlmlr/ulimit")
library(benchmarkme)

RAM <- print(benchmarkme::get_ram())
## Convert GB to Mib
RAM_Mib <- strsplit(RAM, " ")[[1]][1] %>% as.numeric() * 953.67431640625
cat(paste("Available RAM:",RAM))
## Set new memory limit 
ulimit::memory_limit(RAM_Mib) 
```


## Load Data

```{r Load Data }   
## ! IMPORTANT! Must not setwd to local path when launching on cluster
# setwd("~/Desktop/PD_scRNAseq/")
dir.create(file.path(root,"Data"), showWarnings=F) 
load(file.path(root,"Data/seurat_object_add_HTO_ids.Rdata"))
DAT <- seurat.obj  
rm(seurat.obj)
```

### Pre-filtered Dimensions

```{r Pre-filtered Dimensions}
DAT
```


## Clean Metadata

```{r Clean Metadata, include=F, eval=F}
library(readxl)

## Update dx and mut fields
### Import updated  dx, mut info
subjectInfo <- read_excel(file.path(root,"Data/scRNAseq_meta.xlsx")) 
### Import metadata
meta <- read.table(file.path(root,"Data/meta.data3.tsv"), header=T )
### Remove last 2 cols (contain incorrect values) and duplicate HTO col
sum(meta$HTO != meta$HTO.1) # double check they're identical

meta["barcode"] = row.names(meta)
unique(meta["HTO"])
# Map incorrect subject IDs to CORRECT subject IDs (typos occurred at NYGC during processing)
map = setNames( # Incorrect (from NYGC)
               c("NYUMD0011", "BIMD0076", "MSMD0067", "BIMD0077", "BIMD0007",
                 "BIMD0075", "NYUMD0015", "MSMD0035","MSMD0207", "BIMD0010"), 
               # Correct (from Evan)
              c("NYUMD0011", "BID0076", "MSMD0067", "BID0077", "BIMD0007",
                 "BID00075","NYUMD0015", "MSMD0035", "MSMD0207", "BIMD0010")
              )
meta["ID"] <- map[unlist(meta["HTO"])]
meta <- subset(meta, select = -c(dx, mut, HTO, HTO.1)) 
### Merge new cols
metadata <- merge(meta, subjectInfo, by="ID", all.x=T) 
row.names(metadata) <- metadata$barcode
colnames(metadata)[colnames(metadata)=="Ethnitcity"] <- "Ethnicity" 
# Remove "CellType" (these were just clusters identified previously with an old pipeline, no longer being used)
metadata <- subset(metadata, select = -CellType)

dim(meta)
dim(metadata)
head(metadata)
paste("singlet.or.not.binary =",unique(DAT@meta.data$singlet.or.not.binary))
# Correct misspelling
### Export updated Metadata
write.table(metadata, file.path(root,"Data/meta.data4.tsv"))
# Add metadata to seurat object
DAT <- AddMetaData(object = DAT, metadata =  metadata )  

rm(list = c("meta", "metadata", "map", "subjectInfo"))
## % Mitochondrial genes metadata
#mito.genes <- grep(pattern = "^MT-", x = rownames(x = DAT@data), value = TRUE)
#percent.mito <- Matrix::colSums(DAT@raw.data[mito.genes, ])/Matrix::colSums(DAT@raw.data)
#DAT <- AddMetaData(object = DAT, metadata = percent.mito, col.name = "percent.mito")
```


## Add Metadata

```{r Subset for Testing, results="asis"}  
metadata <- read.table(file.path(root,"Data/meta.data4.tsv"))
createDT( metadata, caption = "Metadata")  

# Make AgeGroups
makeAgeGroups <- function(){
  dim(metadata)
  getMaxRound <- function(vals=metadata$Age, unit=10)unit*ceiling((max(vals)/unit))
  getMinRound <- function(vals=metadata$Age, unit=10)unit*floor((min(vals)/unit)) 
   
  ageBreaks = c(seq(getMinRound(), getMaxRound(), by = 10), getMaxRound()+10)
  AgeGroupsUniq <- c()
  for (i in 1:(length(ageBreaks)-1)){ 
    AgeGroupsUniq <- append(AgeGroupsUniq, paste(ageBreaks[i],ageBreaks[i+1], sep="-")) 
  } 
  data.table::setDT(metadata,keep.rownames = T,check.names = F)[, AgeGroups := cut(Age, 
                                  breaks = ageBreaks, 
                                  right = F, 
                                  labels = AgeGroupsUniq,
                                  nclude.lowest=T)]
  metadata <- data.frame(metadata)
  unique(metadata$AgeGroups)
  head(metadata)
  dim(metadata)
  return(metadata)
}
# metadata <- makeAgeGroups()

DAT <- AddMetaData(object = DAT, metadata = metadata)  
# Get rid of any NAs (cells that don't match up with the metadata) 
if(subsetCells==F){
  DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0)
} else {DAT <- FilterCells(object = DAT,  subset.names = "nGene", low.thresholds = 0,
                    # Subset for testing 
                    cells.use = DAT@cell.names[0:subsetCells]
                    )
}  
```




## Filter & Normalize Data

### Subset Genes by Biotype

Include only subsets of genes by type.
Biotypes from: https://useast.ensembl.org/info/genome/genebuild/biotypes.html

```{r Subset Genes by Biotype}
subsetBiotypes <- function(DAT, subsetGenes){
  if( subsetGenes!=F ){
    cat(paste("Subsetting genes:",subsetGenes, "\n"))
    # If the gene_biotypes file exists, import csv. Otherwise, get from biomaRt
    if(file_test("-f", file.path(root,"Data/gene_biotypes.csv"))){
      biotypes <- read.csv(file.path(root,"Data/gene_biotypes.csv"))
    }
    else {
      ensembl <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org",
                       dataset="hsapiens_gene_ensembl") 
      ensembl <- useDataset(mart = ensembl, dataset = "hsapiens_gene_ensembl")
      listFilters(ensembl)
      listAttributes(ensembl)   
      biotypes <- getBM(attributes=c("hgnc_symbol", "gene_biotype"), filters="hgnc_symbol",
            values=row.names(DAT@data), mart=ensembl) 
      write.csv(biotypes, file.path(root,"Data/gene_biotypes.csv"), quote=F, row.names=F)
    } 
    # Subset data by creating new Seurat object (annoying but necessary)
    geneSubset <- biotypes[biotypes$gene_biotype==subsetGenes,"hgnc_symbol"] 
    
    cat(paste(dim(DAT@raw.data[geneSubset, ])[1],"/", dim(DAT@raw.data)[1], 
                "genes are", subsetGenes))
    # Add back into DAT 
    subset.matrix <- DAT@raw.data[geneSubset, ] # Pull the raw expression matrix from the original Seurat object containing only the genes of interest
    DAT_sub <- CreateSeuratObject(subset.matrix) # Create a new Seurat object with just the genes of interest
    orig.ident <- row.names(DAT@meta.data) # Pull the identities from the original Seurat object as a data.frame
    DAT_sub <- AddMetaData(object = DAT_sub, metadata = DAT@meta.data) # Add the idents to the meta.data slot
    DAT_sub <- SetAllIdent(object = DAT_sub, id = "ident") # Assign identities for the new Seurat object
    DAT <- DAT_sub
    rm(list = c("DAT_sub","geneSubset", "subset.matrix", "orig.ident")) 
  } 
  return(DAT)
}

DAT <- subsetBiotypes(DAT, subsetGenes)
```

### Subset Cells

Filter by cells, normalize , filter by gene variability.  

```{r Subset Cells }
cat("Total Cells:", length(DAT@cell.names), "\n")
DAT <- FilterCells(object = DAT, subset.names = c("nGene", "percent.mito"), 
    low.thresholds = c(200, -Inf), high.thresholds = c(2500, 0.05))
cat("Filtered Cells:", length(DAT@cell.names))

DAT <- NormalizeData(object = DAT, normalization.method = "LogNormalize", 
    scale.factor = 10000)
```

### Subset Genes by Variance

__Important!__:
* In ScaleData...
  + Specify do.par = F (unless you have parallel processing set up properly, this will cause your script to crash)
  + Specify num.cores = nCores (to use all available cores, determined by parallel::detectCores())

Regress out: number of unique transcripts (nUMI), % mitochondrial transcripts (percent.mito) 
```{r Subset Genes by Variance} 
# Store the top most variable genes in @var.genes
DAT <- FindVariableGenes(object = DAT, mean.function = ExpMean, dispersion.function = LogVMR,
    x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5)
cat("Total Genes:", length(row.names(DAT@raw.data)), "\n")
cat("Highly Variable Genes:", length(DAT@var.genes))

# IMPORTANT!: Must set do.par=T and num.cors = n for large datasets being processed on computing clusters
# IMPORTANT!: Use only the var.genes identified by 'FindVariableGenes' as the 'gene.use' arg in 'ScaleData'
## This will greatly reduced the computational load.

# Ensure CD14 and CD16 are included
appendedGenes <- c(DAT@var.genes, "CD14", "FCGR3A")
DAT <- ScaleData(object = DAT, genes.use = appendedGenes , vars.to.regress = c("nUMI", "percent.mito"), 
                  do.par = T, num.cores = nCores)
```

### Filtered Dimensions

```{r Filtered Dimensions}
DAT
```



# Diagnostic Plots

## Violin Plots
```{r Violin Plots }  
vp <- VlnPlot(object = DAT, features.plot = c("nGene", "nUMI", "percent.mito"),nCol = 3, do.return = T) %>% + ggplot2::aes(alpha=0.5)
vp
```

## Gene Plots {.tabset .tabset-fade .tabset-pills}

### percent.mito plot

```{r percent.mito - process, echo = T, results = 'hide', fig.show='hide'} 
# par(mfrow = c(1, 2))
# do.hover <- ifelse(interactive==T, T, F)
gp1 <- GenePlot(object = DAT, gene1 = "nUMI", gene2 = "percent.mito", pch.use=20) 
         #do.hover=do.hover, data.hover = "mut")
```

```{r percent.mito - plot} 
gp1
```
 
### nGene plot

```{r nGene - process, echo = T, results = 'hide', fig.show='hide'}
# do.hover <-ifelse(interactive==T, T, F)
gp2 <- GenePlot(object = DAT, gene1 = "nUMI", gene2 = "nGene", pch.use=20)
         #do.hover=do.hover, data.hover = "mut")
```

```{r nGene - plot}
gp2
```


# Dimensionality Reduction

## PCA {.tabset .tabset-fade .tabset-pills}

ProjectPCA scores each gene in the dataset (including genes not included
in the PCA) based on their correlation with the calculated components.
Though we don't use this further here, it can be used to identify markers
that are strongly correlated with cellular heterogeneity, but may not have
passed through variable gene selection.  The results of the projected PCA
can be explored by setting use.full=T in the functions above

* Other Dim Reduction Methods in Seurat
  + RunCCA()
  + RunMultiCCA()
  + RunDiffusion()
  + RunPHATE() 
  + RunICA()
  
```{r PCA }
# Run PCA with only the top most variables genes
DAT <- RunPCA(object = DAT, pc.genes = DAT@var.genes, do.print=F, verbose=F) #, pcs.print = 1:5,  genes.print = 5
# Store in Seurat object so you don't have to recalculate it for the tSNE/UMAP steps
DAT <- ProjectPCA(object = DAT, do.print=F) 
```

### VizPCA

```{r VizPCA}
VizPCA(object = DAT, pcs.use = 1:2)
```

### PCHeatmaps

```{r PCHeatmap, message=F, warning=F}  
# 'PCHeatmap' is a wrapper for heatmap.2  
PCHeatmap(object = DAT, pc.use = 1:12,do.balanced=T, label.columns=F, use.full=F)   # cells.use = 500, 
```


### Significant PCs

Determine statistically significant PCs for further analysis.
NOTE: This process can take a long time for big datasets, comment out for
expediency.  More approximate techniques such as those implemented in
PCElbowPlot() can be used to reduce computation time

```{r Significant PCs }
#DAT <- JackStraw(object = DAT, num.replicate = 100, display.progress = FALSE)
PCElbowPlot(object = DAT)
```

## Find Cell Clusters
* We first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). To cluster the cells, we apply modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function.
  + The clustering approach in FindClusters was heavily inspired by recent manuscripts which applied graph-based clustering approaches to scRNA-seq data [SNN-Cliq, Xu and Su, Bioinformatics, 2015](http://bioinformatics.oxfordjournals.org/content/early/2015/02/10/bioinformatics.btv088.abstract) and CyTOF data [PhenoGraph, Levine et al., Cell, 2015](https://www.ncbi.nlm.nih.gov/pubmed/26095251).
  + To further increase speed, you can employ an approximate nearest neighbor search via the RANN package by increasing the nn.eps + parameter. 
  Setting this at 0 (the default) represents an exact neighbor search.
  + By default, we perform 100 random starts for clustering and select the result with highest modularity. You can lower this through the n.start
  parameter to reduce clustering time.
  + Algorithm for modularity optimization (1 = original Louvain algorithm; 2 = Louvain algorithm with multilevel refinement; 3 = SLM algorithm).


* __On Resolution__  
  + The FindClusters function implements the procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.6-1.2 typically returns good results for single cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters are saved in the object@ident slot.

```{r Cluster Cells}  
DAT <- RunTSNE(object=DAT,  reduction.use = "pca", dims.use = 1:10, do.fast = TRUE,
                perplexity = perplexity, tsne.method = "Rtsne", num_threads=nCores, verbose=F) #   FItSNE 

# TRY DIFFERENT RESOLUTIONS
DAT <- StashIdent(object = DAT, save.name = "pre_clustering") 
# DAT <- SetAllIdent(object = DAT, id = "pre_clustering") 

DAT <- FindClusters(object = DAT, reduction.type = "pca", dims.use = 1:10, algorithm = 1,
                     resolution = resolution, print.output = T, save.SNN = T,
                     n.start = 10, nn.eps = 0.5, plot.SNN = T, force.recalc=T) 
PrintFindClustersParams(object = DAT) 

DAT <- StashIdent(object = DAT, save.name = "post_clustering") 
```

### PCA plot

```{r PCAplot} 
# do.hover <-ifelse(interactive==T, T, F)
PCAPlot(object = DAT, dim.1 = 1, dim.2 = 2, group.by="post_clustering")#, do.hover=do.hover, data.hover="mut")
```

## UMAP

Additional UMAP arguments detailed here: https://umap-learn.readthedocs.io/en/latest/api.html#module-umap.umap_ 
```{r UMAP, results = 'asis'} 
# cat(print(mem_used()))
DAT <- RunUMAP(object = DAT, reduction.use = "pca", dims.use = 1:10, verbose=TRUE, num_threads=nCores) # , num_threads=0
# cat(print(mem_used()))
# Plot results
DimPlot(object = DAT, reduction.use = 'umap')
```



## t-SNE {.tabset .tabset-fade .tabset-pills}

As input to the tSNE, we suggest using the same PCs as input to the clustering analysis, although computing the tSNE based on scaled gene expression is also supported using the genes.use argument.  

**Important!**: Specify num_threads=0 in 'RunTSNE' to use all available cores.

"FItSNE", a new fast implementation of t-SNE, is also available through RunTSNE. However FItSNE must first be setup on your computer.
```{r t-SNE, results = 'asis'} 
labSize <- 12 

customColors <- function(var="post_clustering", palette="Set1"){
  add.alpha <- function(col, alpha=1){ 
    if(missing(col))
      stop("Please provide a vector of colours.")
     apply(sapply(col, col2rgb)/255, 2, 
                       function(x) 
                         rgb(x[1], x[2], x[3], alpha=alpha))  
  } 
  cluster_colors  <- RColorBrewer::brewer.pal( length(unique(DAT@meta.data[var])), palette)
  cluster_colors_transparent <- add.alpha(cluster_colors, .5) %>% as.character()
  return(cluster_colors_transparent)
}

# Try t-SNE at different perplexities
for (i in c(perplexity,5,20,30,100)){
   cat('\n')   
   cat("### t-SNE: perplexity =",i,"\n") 
   DAT <- RunTSNE(object=DAT,  reduction.use = "pca", dims.use = 1:10, do.fast = TRUE,
                perplexity = i, tsne.method = "Rtsne", num_threads=nCores, verbose=F) #   FItSNE
  tsnePlot <- TSNEPlot(object = DAT, do.label=T, label.size = labSize, do.return=T) + 
    scale_color_brewer( palette = "Set1", aesthetics = aes(alpha=.5))
  print(tsnePlot)
  cat('\n')   
} 
```


## t-SNE + Metadata Plots {.tabset .tabset-fade .tabset-pills}

```{r t-SNE + Metadata, warning=F, message=F, results='asis'}
tSNE_metadata_plot <- function(var, labSize=12){ 
  # Metadata plot  
  p1 <- TSNEPlot(DAT, do.return = T,  do.label = T,  group.by = var,label.size = labSize,
                 plot.title=paste(var), vector.friendly=T) +
    theme(legend.position = "top") + 
    scale_color_brewer( palette = "Dark2",  aesthetics = aes(alpha=.5)) 
     
  # t-SNE clusters plot
  p2 <- TSNEPlot(DAT, do.return = T, do.label = T,label.size = labSize,
                 plot.title=paste("Unsupervised Clusters"), vector.friendly=T)  +
    theme(legend.position = "top") + 
    scale_color_brewer( palette = "Set1", aesthetics = aes(alpha=.5))  
  print(plot_grid(p1,p2))
     
}   
# Iterate plots over metadata variables
metaVars <- c("dx","mut","Gender","Age", "ID")
for (var in metaVars){
  cat('\n')
  cat("### t-SNE Metadata plot for ",var, "\n") 
  tSNE_metadata_plot(var)
  cat('\n') 
} 
```

 

# Cluster Biomarkers

Seurat has several tests for differential expression which can be set with the test.use parameter (see the DE vignette for details). For example, the ROC test returns the ‘classification power’ for any individual marker (ranging from 0 - random, to 1 - perfect).

Shown here: Biomarkers of each cluster vs. all other clusters.

## Biomarkers Data {.tabset .tabset-fade .tabset-pills}

### All Biomarkers

```{r All Biomarkers} 
# Limit to only top variable genes?: 
# Set arg 'only.pos=F' to capture negative biomarkers
# DAT <- SetIdent(DAT, ident.use = "post_clustering") 

DAT.markers <- FindAllMarkers(object = DAT, min.pct = 0.25, thresh.use = 0.25,  only.pos = F,  test.use = "wilcox")
DAT.markers <- DAT.markers %>% mutate(FC = 2^avg_logFC)

DAT.markers.sig <- DAT.markers %>% subset(p_val_adj<=0.05) 
markers.summary <- DAT.markers.sig %>% group_by(cluster) %>% tally()
# markers.summary <- base::merge(DAT.markers.sig %>% group_by(cluster) %>% tally(),
#       DAT.markers %>% group_by(cluster) %>% summarise(mean(avg_logFC)), 
#       by="cluster" )

createDT(markers.summary, caption = "Number of DEGs and Mean logFC per Cluster")

createDT(DAT.markers, caption = paste("All Biomarkers: All Clusters"))
```

### Top Biomarkers

```{r Top Biomarkers} 
topNum = 5
topBiomarkers <- DAT.markers %>% group_by(cluster) %>% top_n(topNum, avg_logFC)
createDT(DAT.markers, caption = paste("All Biomarkers: All Clusters"))
```


## Cluster Biomarker: Violin Plots {.tabset .tabset-fade .tabset-pills}

```{r cluster biomarker plots, results='asis'}

getTopBiomarker <- function(DAT.markers, clusterID, topN=1){
  df <-DAT.markers %>%
    subset(p_val_adj<0.05 & cluster==as.character(clusterID)) %>%
    arrange(desc(avg_logFC))
    top_pct_markers <- df[1:topN,"gene"]
  return(top_pct_markers)
}
# clust1_biomarkers <- getTopBiomarker(DAT.markers, clusterID=1, topN=2)
# clust2_biomarkers <- getTopBiomarker(DAT.markers, clusterID=2, topN=2)


### Plot biomarkers 
plotBiomarkers <- function(DAT, biomarkers, cluster){
  biomarkerPlots <- list()
  for (marker in biomarkers){ 
    p <- VlnPlot(object = DAT, features.plot = c(marker), y.log=T, return.plotlist=T) 
    biomarkerPlots[[marker]] <- p + ggplot2::aes(alpha=0.5) + xlab( "Cluster") + ylab( "Expression")
  }
  combinedPlot <- do.call(grid.arrange, c(biomarkerPlots, list(ncol=2, top=paste("Top DEG Biomarkers for Cluster",cluster))) ) 

  # biomarkerPlots <- lapply(biomarkers, function(marker) {
  #   VlnPlot(object = DAT, features.plot = c(marker), y.log=T, return.plotlist=T) %>% + ggplot2::ggtitle(marker) %>% ggplotly() 
  # })    
  # return(subplot(biomarkerPlots) )
}   

top1 <- DAT.markers %>% group_by(cluster) %>% top_n(1, avg_logFC) 
nCols <- floor( sqrt(length(unique(top1$cluster))) )   
figHeight <- nCols *7

# Plot top 2 biomarker genes for each 
for (clust in unique(DAT.markers$cluster)){ 
   cat('\n')   
   cat("### Cluster ",clust,"\n") 
   biomarkers <- getTopBiomarker(DAT.markers, clusterID=clust, topN=2)
   plotBiomarkers(DAT, biomarkers, clust)  
   cat('\n')   
} 
```
 
## Cluster Biomarker: Volcano Plots {.tabset .tabset-fade .tabset-pills}

```{r Volcano Plots, fig.height=5, fig.width=5, results='asis'}
##Construct the plot object
volcanoPlot <- function(DEG_df, caption="", topFC_labeled=5){
  DEG_df$sig<-  ifelse( DEG_df$p_val_adj<0.05 & DEG_df$avg_logFC<1.5, "p_val_adj<0.05",
            ifelse( DEG_df$p_val_adj<0.05  & DEG_df$avg_logFC>1.5, "p_val_adj<0.05 & avg_logFC>1.5",
		        "p_val_adj>0.05"
		)) 
  DEG_df <- arrange(DEG_df, desc(sig))
  yMax  <- max(-log10(DEG_df$p_val_adj)) + max(-log10(DEG_df$p_val_adj))/3 #ifelse(max(-log10(DEG_df$p_val_adj))<45, 50, max(-log10(DEG_df$p_val_adj)) + 10)
  
  vol <- ggplot(data=DEG_df, aes(x=avg_logFC, y= -log10(p_val_adj))) +
    geom_point(alpha=0.5, size=3, aes(col=sig)) + 
    scale_color_manual(values=list("p_val_adj<0.05"="turquoise3",
                                   "p_val_adj<0.05 & avg_logFC>1.5"="purple", 
                                   "p_val_adj>0.05" = "darkgray")) +
    theme(legend.position = "none") + 
    xlab(expression(paste("Average ",log^{2},"(fold change)"))) +
    ylab(expression(paste(-log^{10},"(p-value)"))) + xlim(-2,2) + ylim(0, yMax) +
    ## ggrepl labels
    geom_text_repel(data= arrange(DEG_df,  p_val_adj, desc(avg_logFC))[1:topFC_labeled,], 
                    # filter(DEG_df, avg_logFC>=1.5)[1:10,],
                    aes(label=gene),  color="black", alpha=.5,
                    segment.color="black", segment.alpha=.5  
                    ) +  
    # Lines
    geom_vline(xintercept= -1.5,lty=4, lwd=.3, alpha=.5) + 
    geom_vline(xintercept= 1.5,lty=4, lwd=.3, alpha=.5) +
    geom_hline(yintercept= -log10(0.05),lty=4, lwd=.3, alpha=.5) + 
    ggtitle(caption) 
  print(vol)
}


# Run plots
for (clust in unique(DAT.markers$cluster)){
   cat('\n')   
   cat("### Cluster ",clust,": Volcano","\n") 
   cap <- paste("Cluster",clust,"DEG Table") 
   DEG_df <- subset(DAT.markers, cluster==as.character(clust)) %>% arrange(desc(avg_logFC))  
   volcanoPlot(DEG_df, caption = cap)
   createDT_html(DEG_df, caption = cap)
   cat('\n')   
} 
```


## Top Biomarker Plot

### Biomarkers GO {.tabset .tabset-fade}

```{r Biomarkers GO, results='asis'}
for (clust in top1$cluster){ 
  subClust <- subset( top1, cluster==clust)
  cat('\n')
  cat("### Cluster",clust,"\n")
  cat( "Biomarker\n",subClust$gene) 
  results <- Seurat::FindGeneTerms(QueryGene = subClust$gene) 
  print(results) #parse_html_notebook(results)
  cat('\n')
}
```


###  Biomarkers tSNE

```{r Biomarkers tSNE, out.height="300%"} 
fp <- FeaturePlot(object = DAT, features.plot = top1$gene, cols.use = c("grey", "purple"), 
    reduction.use = "tsne", nCol = nCols, do.return = T)
```


### Biomarkers Heatmap

```{r Biomarkers Heatmap}
top5 <- DAT.markers %>% group_by(cluster) %>% top_n(5, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = DAT, genes.use = top5$gene, slim.col.label=T, remove.key=T) 
# ifelse(interactive, p %>% ggplotly() %>% toWebGL() %>% print(), print(p))
```

### Biomarkers Ridgeplot

```{r Biomarkers RidgePlot}
RidgePlot(DAT, features.plot = top1$gene,  nCol = nCols, do.sort = F)
```

### Biomarkers Split Dot Plot

Visualize biomarker expression for each cluster, by disease

```{r Biomarkers Split Dot Plot} 
top2 <- DAT.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)

sdp <- SplitDotPlotGG(DAT, genes.plot = top2$gene, cols.use = c("blue","red"), 
                      x.lab.rot = T, plot.legend = T, dot.scale = 8, do.return = T, grouping.var = "dx")
```

# Map Clusters to Known Biomarkers

- Known Monocytes Biomarkers
 + Classical: CD14++ / CD16--
 + Intermediate: CD14++ / CD16+
 + Nonclassical: CD14+ / CD16++ (not captured in this data)
 
 The following plots show the absolute expression of each biomarker, 
 as opposed to avg_logFC which is dependent on the expression patterns of other cell types being compared.
  
## Markers Dataframe

```{r Markers Dataframe}
markerList <- c("CD14", "FCGR3A") 
 
get_markerDF <- function(DAT, markerList, meta_vars =c("barcode", "dx", "mut","post_clustering", "percent.mito","nGene", "nUMI")){
  exp <- DAT@scale.data %>% data.frame() 
  marker.matrix <- exp[row.names(exp) %in% markerList, ] 
  marker.matrix$Gene <- row.names(marker.matrix)
  markerMelt <- reshape2:::melt.data.frame(marker.matrix, id.vars = "Gene", variable.name = "Cell",value.name = "Expression") 
  metaSelect <-  DAT@meta.data[,meta_vars] 
  markerDF <- merge(markerMelt,metaSelect, by.x="Cell", by.y="barcode") 
  return(markerDF)
}
markerDF <- get_markerDF(DAT, markerList)
createDT(markerDF, caption = "Known Marker Expression")
```

## Marker ANOVAs + Boxplots 

```{r Marker ANOVAs + Boxplots } 
# Explore expression differences between groups
marker_vs_metadata <- function(markerDF, meta_var){ 
  # Create title from ANOVA summary
  ANOVAtitle <- function(markerDF, marker){
      nTests <- length(unique(markerDF$Gene))
      res <- anova(lm(data = subset(markerDF, Gene==marker), 
                      formula = Expression ~ eval(parse(text=meta_var))))
      
      title <-paste(paste("ANOVA (",marker, " vs. ",meta_var, ")", sep=""), 
                    ": p=",round(res$`Pr(>F)`,3), 
                    ", F=",round(res$`F value`,3), 
        ifelse(res$`Pr(>F)`<.05/nTests,"(Significant**)",
               "(Non-significant)") ) 
  }
  
  title = ""
  for (marker in unique(markerDF$Gene) ){
    cat(marker)
    title <- paste(title, "\n", ANOVAtitle(markerDF, marker))
  } 
   
 
  ggplot(markerDF, aes(x=eval(parse(text=meta_var)), y=Expression, fill= Gene)) + 
    geom_violin() + 
      geom_point( position=position_jitterdodge(jitter.width = .2, dodge.width = .9 ),   alpha=0.6, color="turquoise3") + 
    labs(title = title, x=meta_var) +
    theme(plot.title = element_text( size=10)) +
    scale_fill_manual(values=c("brown", "slategray"))
  
}
```

### ANOVA: dx

```{r ANOVA: dx} 
marker_vs_metadata(markerDF, "dx")
```

### ANOVA: mut

```{r ANOVA: mut}
marker_vs_metadata(markerDF, "mut")
```




## Defining Cell-types  

### Identify Cell Types By DEGs

* Classification Approach 1
  + Go through each cluster and see what biomarkers they have through DGE. 
  + If a cluster has a known gene marker within their top N biomarkers (with the right valence +/-), 
classify all cells within that cluster as a given cell type.
  + __Drawback__: The biomarkers that DGE identifies for each cluster will depend on the composition of the other cells. 
So some clusters may remain unidentified simply by the fact that they didn't have the proper cells to be compared to.
```{r Identify Cell Types By DEGs, out.width="150%", out.height="150%"} 
identify_cellTypes_by_biomarkers <- function(DAT.markers, topN_search=5){
  top <- DAT.markers %>% group_by(cluster) %>% top_n(topN_search, avg_logFC) 
  clust_cellTypes <- list()
  for (clust in top$cluster){ 
    clustSub <- top[top5$cluster==clust, ]
    CD16_logFC <- subset(clustSub, gene=="CFD")$avg_logFC 
    
    cellType <- ifelse(sum(markerList %in% clustSub$gene), # Both CD14 and CD16? Great, keep going
           ifelse(CD16_logFC == abs(CD16_logFC), "CD14++/CD16+",  # But does CD16 have pos logfC? If so, then it's "CD14++/CD16+"
                  "CD14++/CD16--"), # Otherwise, it means it means CD16 logFC is neg, meaning "CD14++/CD16--"
           NA) # If it's none of these, it's an undefined cell type 
     clust_cellTypes[clust] <- as.factor(cellType)
  }
  newMeta <- DAT@meta.data
  newMeta["CellType_DGE"] <- plyr::mapvalues(newMeta$post_clustering, names(clust_cellTypes), as.character(clust_cellTypes) )  
  DAT <- AddMetaData(DAT, metadata = newMeta)
  return(DAT)
} 
DAT <- identify_cellTypes_by_biomarkers(DAT.markers, 5)

# (Doesn't make sense to do bar plot because whole clusters are defined by their biomarkers)

tSNE_metadata_plot("CellType_DGE")
```

 

## Identify Cell Types with Garnett + Monocle

### Pre-trained PBMC Classifer

```{r Identify Cell Types with Garnett}
# Convert Seurat objt to CDS object
mDAT <- monocle::importCDS(DAT,  import_all = T) 
# generate size factors for normalization later
mDAT <- estimateSizeFactors(mDAT)

# Get pre-trained PBMC classifer 
load("hsPBMC") # Download from: https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC 
# Get feature genes for each cell type
feature_genes <- get_feature_genes(hsPBMC,
                                   node = "root",
                                   db = org.Hs.eg.db, 
                                   convert_ids = T)
head(feature_genes)
mDAT <- classify_cells(mDAT, hsPBMC,
                           db = org.Hs.eg.db,
                           cluster_extend = TRUE,
                           cds_gene_id_type = "SYMBOL")
head(pData(mDAT))
table(pData(mDAT)$cell_type)
table(pData(mDAT)$cluster_ext_type) 



# Run tSNE: Plot Clusters and Cell Types 
mDAT <- reduceDimension(mDAT, max_components = 3, reduction_method = "tSNE") 
commonGeoms <- labs(x="tSNE1",y="tSNE2")
plot_grid(nrow = 2,
  qplot(data = pData(mDAT), mDAT@reducedDimA[1,], mDAT@reducedDimA[2,], color = cell_type) + theme_bw() + commonGeoms,
  qplot(data = pData(mDAT), mDAT@reducedDimA[1,], mDAT@reducedDimA[2,], color = cluster_ext_type) + theme_bw() + commonGeoms
)


# Unsupervised Clustering
mDAT <- clusterCells(mDAT, num_clusters = 5)
pData(mDAT)
plot_cell_clusters(mDAT, 1, 2, color = "Cluster",  markers = c("CD14", "FCGR3A"))
plot_cell_clusters(mDAT, 1, 2, color = "Cluster") + facet_wrap(~dx)
plot_cell_clusters(mDAT, 1, 2, color = "Cluster") + facet_wrap(~mut)
plot_cell_clusters(mDAT, 1, 2, color = "Cluster") + facet_wrap(~cell_type) 
```

### Train Classifier on Data

```{r, include=F}

# marker_file_path <- system.file("extdata", "pbmc_test.txt",
#                                 package = "garnett")
# # Plot chosen markers
# marker_check <- check_markers(mDAT, marker_file_path,
#                               db=org.Hs.eg.db,
#                               cds_gene_id_type = "SYMBOL",
#                               marker_file_gene_id_type = "SYMBOL")
#
# plot_markers(marker_check)

# Classify Cells
## Get classifier from
# write.table( RCurl::getURL("https://cole-trapnell-lab.github.io/garnett/marker_files/hsPBMC_markers.txt"),
#              file = "pbmc_markerFile.txt",row.names = F, col.names = F, quote = F, )
# Train Classifier
# classifier <- train_cell_classifier(cds = mDAT,
#                                          marker_file = "pbmc_markerFile.txt",
#                                          db=org.Hs.eg.db,
#                                          cds_gene_id_type = "SYMBOL",
#                                          num_unknown = 50,
#                                          marker_file_gene_id_type = "SYMBOL")
#get_classifier_references(classifier) 
```


# Pseudo-time

WARNING: _Very_ computationally expensive!
```{r Pseudo-time, eval=F}
mDAT <- reduceDimension(mDAT, max_components = 2, method = 'DDRTree')
mDAT <- orderCells(mDAT)
plot_cell_trajectory(mDAT, color_by = "dx")
plot_cell_trajectory(mDAT, color_by = "cell_type")
plot_cell_trajectory(HSMM_myo, color_by = "cell_type") +
    facet_wrap(~mut, nrow = 2)
```






## Known Biomarkers: Heatmaps {.tabset .tabset-fade .tabset-pills}

### Cells Separated

```{r Cells Separated} 
markerDF <- get_markerDF(DAT, markerList, 
             meta_vars =c("barcode", "dx", "mut","ID","post_clustering", "percent.mito","nGene", "nUMI",
                          "CellType_DGE"))
Spectral <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(length(unique(DAT@meta.data$mut)), "Spectral"))

# DAT <- DoKMeans(DAT, k.genes = 3) 
# KMeansHeatmap(DAT)

if (T==F){
  # Spectral <- heatmaply::Spectral(length(unique(DAT@meta.data$mut)))
  markerMelt <- reshape2::acast(markerDF, Cell~Gene, value.var="Expression", fun.aggregate = mean, drop = F, fill = 0) 
  heatmaply::heatmaply(markerMelt,  key.title="Expression",#plot_method= "ggplot",
        k_row = dim(markerMelt)[2], dendrogram = "row",
        showticklabels = c(T, F), xlab = "Known Markers", ylab = "Cells", column_text_angle = 45, 
        row_side_colors =  DAT@meta.data[,c("dx","mut", "CellType_DGE")], row_side_palette = Spectral
        )  %>%  colorbar(tickfont = list(size = 12), titlefont = list(size = 14), which = 2)  %>% 
        colorbar(tickfont = list(size = 12), titlefont = list(size = 14), which = 1)
 }else{ 
  # markerDF_sub <-subset(markerDF, Gene==markerList[1])  
  # var_to_colors(markerDF_sub, "post_clustering")  
  # library(pheatmap)
  # pheatmap(markerMelt, annotation_row = markerDF_sub[c("dx","mut","CellType_DGE")])
  # pheatmap(markerMelt, kmeans_k = NA, annotation_row = markerDF_sub[c("dx","mut","CellType_DGE")],
  #         cluster_cols = F, cutree_rows = length(unique(markerDF$post_clustering)),  angle_col=45 )
  library(RColorBrewer) 
  var_to_colors <- function(markerDF, metaVar){
    colors <- brewer.pal(length(unique(markerDF[metaVar]) ), "Dark2")
     sample(colors, length(unique(markerDF[metaVar])), replace = TRUE, prob = NULL)
    # metaColors <- colors[ subset(markerDF, Gene==markerList[1])[metaVar][,1] %>% as.factor() ]
    return(metaColors)
  }  
  # library(GMD)
  # myCols = cbind(var_to_colors(markerDF, "dx"), var_to_colors(markerDF, "mut")) 
  # rlab=t(cbind(
  #   var_to_colors(markerDF, "post_clustering"),
  #   var_to_colors(markerDF, "dx")
  #   ))
  #   heatmap.2(marker.matrix, key.title="Expression",  col = viridis(300), trace="none",Colv = F, Rowv = F,
  #             labRow = F, xlab = "Biomarker", ylab="Cell", cexCol=1, RowSideColors = var_to_colors(markerDF, "post_clustering")
  #             )
  # heatmap.3(markerMelt, dendrogram = 'row', kr = length(unique(markerDF)), labRow = F, 
  #           xlab = "Biomarker", ylab = "Cell", RowSideColors = rlab, RowSideColorsSize=2 )
   
  
  
  markerDF <- markerDF %>%    
    mutate_at(vars(post_clustering, dx, mut, ID, CellType_DGE), as.factor) %>% 
    mutate(Cluster = post_clustering) %>%
    arrange(post_clustering) 
  # markerMelt <- reshape2::acast(markerDF, Cell~Gene, value.var="Expression", fun.aggregate = mean, drop = F, fill = 0) 
  markerMelt <- dcast(markerDF,  Cell + post_clustering + dx + mut + ID + CellType_DGE ~ Gene,
                      fun.aggregate = mean, value.var = "Expression") %>% arrange(post_clustering)
  marker.matrix <- markerMelt[markerList] %>%as.matrix()
  row.names(marker.matrix) <- markerMelt$Cell
  
  ha = HeatmapAnnotation(df = markerDF[c("dx","mut","ID","CellType_DGE","post_clustering")], which = "row") 
  
  ComplexHeatmap::Heatmap(marker.matrix, col=viridis(300), column_title = "Biomarker", row_title = "Cell",  
                          row_dend_reorder = F,show_row_names = F, show_column_dend = F,show_row_dend =T,
                          cluster_rows = T, column_title_side = "bottom",km = length(unique(markerMelt$post_clustering))) + ha
 

} 
```

### Average Expression: By Clusters

```{r Clusters Averaged}
markerDF <- markerDF %>% mutate(Cluster = post_clustering)
# Show mean exp for each marker
avgMarker <- markerDF %>% group_by(Gene, Cluster) %>% summarise(meanExp = mean(Expression)) 

p <- ggplot(data = avgMarker, aes(x=Gene, y=Cluster, fill=meanExp)) %>% + geom_tile() + scale_fill_viridis()
p
# ifelse(interactive, p %>% ggplotly() %>% toWebGL() %>% print(), print(p))
```

### Average Expression: By Disease

```{r Average Expression: By Disease}
# Show mean exp for each marker
avgMarker <- markerDF %>% group_by(Gene, dx, Cluster) %>% summarise(meanExp = mean(Expression)) 
p <- ggplot(data = avgMarker, aes(x=Gene, y=dx, fill=meanExp)) %>% + geom_tile() + scale_fill_viridis()
p

# ifelse(interactive, p %>% ggplotly() %>% toWebGL() %>% print(), print(p))
```


## Known Biomarkers: Boxplot

```{r Known Biomarkers: Boxplot} 
ggplot(data = markerDF, aes(x=Cluster, y=Expression, fill=Gene)) %>% 
  + geom_boxplot(alpha=0.5) %>% + scale_fill_manual(values=c("purple", "turquoise"))  
```



##  Known Biomarkers: tSNE

```{r Known Biomarkers: tSNE code, fig.width=12}
#, results = 'hide', fig.show='hide'
expressionTSNE <- function(DAT, marker, colors=c("grey", "red")){
   FeaturePlot(object = DAT, features.plot = marker, cols.use = colors, 
    reduction.use = "tsne", nCol=2, do.return = T, dark.theme = T)[[1]]
  # p <- ifelse(interactive, p %>% ggplotly() %>% toWebGL(), print(p)) 
}
 plot_grid(expressionTSNE(DAT, markerList[1]),
 expressionTSNE(DAT, markerList[2], colors=c("grey", "green")))
```
 


## Label Clusters by DGE Biomarkers

```{r Label Clusters by DGE Biomarkers }
current.cluster.ids <- unique(DAT.markers$cluster) #c(0, 1, 2, 3, 4, 5, 6, 7)
top1 <- DAT.markers %>% group_by(cluster) %>% top_n(1, avg_logFC)
new.cluster.ids <- top1$gene #c("CD4 T cells", "CD14+ Monocytes", "B cells", "CD8 T cells", "FCGR3A+ Monocytes", "NK cells", "Dendritic cells", "Megakaryocytes")

DAT@ident <- plyr::mapvalues(x = DAT@ident, from = current.cluster.ids, to = new.cluster.ids)
TSNEPlot(object=DAT, do.label=T, pt.size=0.5, do.return=T) 
# ifelse(interactive, p %>% ggplotly() %>% toWebGL() %>% print(), print(p)) 
```


# DGE: All Cells {.tabset .tabset-fade .tabset-pills}

- DGE methods available in Seurat include:
 + DESeq2DETest()
 + DiffExpTest()
 + DiffTTest() 
```{r All Cells: function} 
# Available DGE methods:
## "wilcox", "bimod", "roc", "t", "tobit", "poisson", "negbinom", "MAST", "DESeq2"
runDGE <- function(DAT, meta_var, group1, group2, test.use="wilcox"){
  #print(paste("DGE_allCells",meta_var,sep="_")) 
  DAT <- SetAllIdent(DAT, id = meta_var)
  DAT <- StashIdent(DAT, save.name = meta_var)  
  DEGs <- FindMarkers(DAT, ident.1=group1, ident.2=group2, test.use=test.use, only.pos = F)
  DEGs$gene <- row.names(DEGs)
  
  cap <- paste("DEGs:\n",group1, "vs.", group2)
  createDT_html(DEG_df, caption = cap)
  volcanoPlot(DEG_df, caption = cap)
  
  DAT <- SetAllIdent(DAT, id = "post_clustering")
  return(DEGs)
}
```

## PD vs. Controls

```{r All Cells: PD vs. Controls}
DEG_df <-runDGE(DAT, "dx", group1 = "PD", group2="control")
```

## LRRK vs. PD

```{r All Cells: LRRK2 vs. PD} 
DEG_df <-runDGE(DAT, "mut", "LRRK2", "PD")
```

## CellType_DGE

```{r All Cells: CellType_DGE}  
DEG_df <-runDGE(DAT, "CellType_DGE", "CD14++/CD16+", "CD14++/CD16--") 
```

# DGE: Within Clusters {.tabset .tabset-fade .tabset-pills}

```{r Within Clusters: function} 
DGE_within_clusters <- function(DAT, meta_var, group1, group2){ 
  for (clust in unique(DAT@meta.data$post_clustering)){
    # Subset cells by cluster  
   cat('\n')   
   cat("### ",paste("Cluster ",clust,": ",group1," vs. ", group2, sep="") , "\n")
   DAT_clustSub <- Seurat::SubsetData(DAT, accept.value = clust, subset.raw = T)  
   DEG_df <-runDGE(DAT_clustSub, meta_var, group1, group2 ) 
   cat('\n')   
  } 
}
```


## Between Disease Groups {.tabset .tabset-fade .tabset-pills}

```{r Within Clusters: Between Disease Groups, results='asis'}   
DGE_within_clusters(DAT, "dx", "PD", "control")    
```

## Between Mutation Groups {.tabset .tabset-fade .tabset-pills}

```{r Within Clusters: Between Mutation Groups, results='asis'}
DGE_within_clusters(DAT, "mut", "LRRK2", "PD")
```

## Between CellType_DGE {.tabset .tabset-fade .tabset-pills}

```{r Within Clusters: CellType_DGE, results='asis'}
DGE_within_clusters(DAT, "CellType_DGE", "CD14++/CD16+", "CD14++/CD16--") 
```


# Try Different Cluster Resolutions {.tabset .tabset-fade .tabset-pills}

If you perturb some of our parameter choices above (for example, setting resolution=0.8 or changing the number of PCs), you might see the CD4 T cells subdivide into two groups. You can explore this subdivision to find markers separating the two T cell subsets. However, before reclustering (which will overwrite object@ident), we can stash our renamed identities to be easily recovered later.

## Find New Clusters

```{r Find New Clusters, fig.width=12}
new_resolution <- 3.0
orig_resolution <- paste("resolution",params$resolution,sep="_")
DAT <- StashIdent(object = DAT, save.name = orig_resolution) 

## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type
## = reduction.type, : Build parameters exactly match those of already
## computed and stored SNN. To force recalculation, set force.recalc to TRUE.
DAT <- FindClusters(object = DAT, reduction.type = "pca", dims.use = 1:10,
                     resolution = new_resolution, print.output = F)
DAT <- StashIdent(object = DAT, save.name = "resolution_3.0") 

plot1 <- TSNEPlot(object = DAT, do.return = TRUE, no.legend = TRUE, do.label = TRUE, label.size=labSize)
plot2 <- TSNEPlot(object = DAT, do.return = TRUE, group.by = "post_clustering", 
                  no.legend = TRUE, do.label = TRUE, label.size=labSize)
plot_grid(plot1, plot2)
```

## Find New Biomarkers

```{r Find New Biomarkers, out.height="300%"}  
res3.0_markers <- FindAllMarkers(object = DAT, min.pct = 0.25, thresh.use = 0.25,  only.pos = F,  test.use = "wilcox")
top1_res3.0 <- res3.0_markers %>% group_by(cluster) %>% top_n(1, avg_logFC) 

FeaturePlot(object = DAT, features.plot = top1_res3.0$gene, cols.use = c("green", "blue"))

# Set back to orig
DAT <- SetAllIdent(object = DAT, id = orig_resolution) 
```





# Enrichment

```{r Enrichment}
enrichr_dbs <- c("KEGG_2018", "Reactome_2016",
                 "GO_Biological_Process_2018", "GO_Molecular_Function_2018", "GO_Cellular_Component_2018", 
                 "Rare_Diseases_AutoRIF_ARCHS4_Predictions", "Human_Gene_Atlas")
createDT(enrichR::listEnrichrDbs(), "Enrichr Databases")
```


## Enrichr on Clusters {.tabset .tabset-fade .tabset-pills}

```{r Enrichr on Clusters, results='asis'} 
for (clust in unique(DAT.markers.sig$cluster)){
  cat('\n')
  cat("### Cluster ",clust,"{.tabset .tabset-fade}\n")
  geneList <- subset(DAT.markers.sig, cluster==clust)$gene  %>% as.character()
  results <- enrichr(genes = geneList, databases = enrichr_dbs )
  for (db in enrichr_dbs){
    cat('\n')
    cat("#### ",db,"\n")  
    createDT_html(subset(results[[db]], Adjusted.P.value<=0.05), paste("Enrichr Results: ",db,"Cluster ", clust))
    cat('\n')
  } 
  cat('\n')
} 
```

## Enrichr on WGCNA Modules {.tabset .tabset-fade .tabset-pills}

* __Background__: Bulk RNA-seq was conducted on monocytes extracted from the blood of controls and PD patients. Katia Lopes conducted Weighted Correlation Network Analysis (WGCNA) on these sameples and identified co-expression modules.
* __Objective__: Determine whether any of these modules are representative of cell groups in our scRNA-seq monocytes data.

```{r Enrichr on WGCNA Modules, results='asis'}
eigengenes <- read.delim("Data/bulkMonocytes_WGCNAmodules_geneMembership.txt", row.names = NULL)
modules <- read.delim("Data/bulkMonocytes_WGCNAmodules_geneModules.txt", row.names = NULL, sep = "", 
                      col.names = c("Ensembl","moduleColors")) 
modules <- base::merge(eigengenes, modules,by="Ensembl" )

for (mod in unique(modules$moduleColors)){
  cat('\n')
  cat("### Module ",mod,"{.tabset .tabset-fade}\n")
  geneList <- subset(modules, moduleColors==mod)$symbol %>% as.character()
  results <- enrichr(genes = geneList, databases = enrichr_dbs )
  for (db in enrichr_dbs){
    cat('\n')
    cat("#### ",db,"\n")  
    createDT_html(subset(results[[db]], Adjusted.P.value<=0.05), paste("Enrichr Results:",db,"Module", mod))
    cat('\n')
  } 
  cat('\n')
}
```

## WGCNA Eigengenes

Determine whether each of the clusters in scRNA-seq data are enriched for WGCNA eigengenes (a weighted vector of all genes representing each co-expression module).
 
https://ucdavis-bioinformatics-training.github.io/2017_2018-single-cell-RNA-sequencing-Workshop-UCD_UCB_UCSF/day3/scRNA_Workshop-PART6.html
```{r WGCNA Eigengenes, eval=F}
#Get the average expression of every gene in each cluster
allGenes <- get_markerDF(DAT, markerList = row.names(DAT@scale.data), meta_vars = c("post_clustering", "barcode") )

clusterGeneAvg <- allGenes %>% group_by(post_clustering, Gene) %>% summarise(meanExp = mean(Expression))
eigengenes_filt <-  subset(eigengenes,symbol %in%  unique(clusterGeneAvg$Gene))


clusts_by_mods <- base::merge(clusterGeneAvg[c("Gene","meanExp")], eigengenes_filt[c("symbol", modName)], 
                              by.x="Gene", by.y="symbol")


cor.test()
corrplot()
heatmap.2
 

f <- function(module){
  eigengene <-  eigengenes[paste0("MM", mod)]
  means <- tapply(eigengenes, DAT@meta.data$post_clustering, mean, na.rm = T)
  return(means)
}
modules <- c("blue", "brown", "green", "turquoise", "yellow")
plotdat <- sapply(modules, f)
matplot(plotdat, col = modules, type = "l", lwd = 2, xaxt = "n", xlab = "Seurat Cluster",
        ylab = "WGCNA Module Eigengene")
axis(1, at = 1:16, labels = 0:15)
matpoints(plotdat, col = modules, pch = 21)
```


### RRHO

```{r RRHO, eval=F}
library(RRHO) #BiocManager::install("RRHO")

# list.length <- 100
#  list.names <- paste('Gene',1:list.length, sep='')
# gene.list1<- data.frame(list.names, sample(100))
# gene.list2<- data.frame(list.names, sample(100))


for (clust in unique(DAT.markers.sig)){
  # Compare each cluster
  subClust <- subset(DAT.markers.sig, cluster==clust)  %>% arrange(desc(avg_logFC))
  
  for (mod in unique(modules$moduleColors)){ 
    # Sort genes by module membership
    modName <-paste("MM",mod,sep="")
    subMod <- subset(modules, moduleColors==mod) %>% arrange(desc(eval(parse(text = modName))))
    maxGenes <- min(length(subClust$gene), subMod$symbol) %>% as.numeric()
    
    list1 <- subClust[1:maxGenes, c("gene","FC")] %>% dplyr::rename(value=FC)
    list2 <- subMod[1:maxGenes, c("symbol",modName)] %>% dplyr::rename(gene=symbol, value=modName)
    
    RRHO_path <-file.path("RRHO_results",paste(paste("Cluster",clust,sep=""),"vs",modName,sep="_"))
    dir.create(RRHO_path,recursive = T, showWarnings = F)
    
    RRHO_results <- RRHO(list1=list1, list2=list2,
         labels = c(paste("Cluster",clust,sep="_"), paste("Module",mod,sep="_")), 
         plots = T, alternative = "enrichment", outputdir = RRHO_path, BY=TRUE
         )
    lattice::levelplot(RRHO_results$hypermat) 
    # Pval testing
    pval.testing <- pvalRRHO(RRHO_results, 50)
    pval.testing$pval
    xs<- seq(0, 10, length=100)
    plot(Vectorize(pval.testing$FUN.ecdf)(xs)~xs, xlab='-log(pvalue)', ylab='ECDF', type='S')
    lattice::levelplot(RRHO_results$hypermat.by)
  } 
}
 


```
  

# Save Results

```{r Save Results} 
# Save results for EACH run (in their respective subfolders)
saveRDS(DAT, file=file.path(params$resultsPath, "cd14-processed.rds") )
```


