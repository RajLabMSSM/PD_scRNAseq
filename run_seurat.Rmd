---  
title: "Parkinson's Disease scRNA-seq: CD14++ Monocytes" 
author: |
  | Brian M. Schilder, Bioinformatician II
  | Raj Lab
  | Department of Neuroscience
  | Icahn School of Medicine at Mount Sinai
  | NYC, New York
date: "12/26/2018" 
output: 
  rmarkdown::html_document: 
    theme: spacelab
    highlight: zenburn 
    code_folding: show 
    toc: true 
    toc_float: true
    smooth_scroll: true
    number_sections: false 
    self_contained: true  
params:
  subsetGenes: "protein_coding" #FALSE
  subsetCells: 400 #FALSE
  resolution: 0.6
  resultsPath: "./" 
---
 

# Setup

```{r setup}    
# Gather parameters from command line  
#dir.create(file.path(resultsPath,"cache"), showWarnings=F, recursive=T)
nCores <- parallel::detectCores()#params$nCores
subsetGenes <- params$subsetGenes 
subsetCells <- params$subsetCells 
resolution <-  as.numeric(params$resolution)   

root <- getwd()
# Have to setwd via knitr
# knitr::opts_knit$set(root.dir=resultsPath, child.path = resultsPath)
knitr::opts_chunk$set(echo=T, error=T, root.dir = resultsPath#cache=T, cache.lazy=T,     
                      ) 
 
kableStyle = c("striped", "hover", "condensed", "responsive") 
# Utilize parallel processing later on 
print(paste("**** Utilized Cores **** =", nCores))   

params
```

** `r params$resultsPath` **
 
 
## Load Libraries & Report Versions
```{r message=F, warning=F}
library(Seurat)
library(dplyr)
library(gridExtra)
library(knitr)
library(kableExtra) 
library(plotly)
library(ggplot2)
library(reshape2)
library(shiny) 
# 
# install.packages('devtools')
# devtools::install_github('talgalili/heatmaply')
## Install Bioconductor
#  if (!requireNamespace("BiocManager"))
#     install.packages("BiocManager")
# BiocManager::install(c("biomaRt"))
library(biomaRt)  
## Seurat::FindGeneTerms() # Enrichr API
## Seurat::MultiModal_CCA() # Integrates data from disparate datasets (CIA version too)

sessionInfo()
print(paste("Seurat ", packageVersion("Seurat")))
```


## Load Data
```{r Load Data }   
#setwd("~/Desktop/PD_scRNAseq/")
dir.create(file.path(root,"Data"), showWarnings=F) 
load(file.path(root,"Data/seurat_object_add_HTO_ids.Rdata"))
pbmc <- seurat.obj  
rm(seurat.obj)
```

### Pre-filtered Dimensions

```{r Pre-filtered Dimensions}
pbmc
```


## Clean Metadata
```{r Clean Metadata, include=F, eval=F}
library(readxl)

## Update dx and mut fields
### Import updated  dx, mut info
subjectInfo <- read_excel(file.path(root,"Data/scRNAseq_meta.xlsx")) 
### Import metadata
meta <- read.table(file.path(root,"Data/meta.data3.tsv"), header=T )
### Remove last 2 cols (contain incorrect values) and duplicate HTO col
sum(meta$HTO != meta$HTO.1) # double check they're identical

meta["barcode"] = row.names(meta)
unique(meta["HTO"])
# Map incorrect subject IDs to CORRECT subject IDs (typos occurred at NYGC during processing)
map = setNames( # Incorrect (from NYGC)
               c("NYUMD0011", "BIMD0076", "MSMD0067", "BIMD0077", "BIMD0007",
                 "BIMD0075", "NYUMD0015", "MSMD0035","MSMD0207", "BIMD0010"), 
               # Correct (from Evan)
              c("NYUMD0011", "BID0076", "MSMD0067", "BID0077", "BIMD0007",
                 "BID00075","NYUMD0015", "MSMD0035", "MSMD0207", "BIMD0010")
              )
meta["ID"] <- map[unlist(meta["HTO"])]
meta <- subset(meta, select = -c(dx, mut, HTO, HTO.1)) 
### Merge new cols
metadata <- merge(meta, subjectInfo, by="ID", all.x=T) 
row.names(metadata) <- metadata$barcode
colnames(metadata)[colnames(metadata)=="Ethnitcity"] <- "Ethnicity" 
# Remove "CellType" (these were just clusters identified previously with an old pipeline, no longer being used)
metadata <- subset(metadata, select = -CellType)

dim(meta)
dim(metadata)
head(metadata)
# Correct misspelling
### Export updated Metadata
write.table(metadata, file.path(root,"Data/meta.data4.tsv"))
# Add metadata to seurat object
pbmc <- AddMetaData(object = pbmc, metadata =  metadata )  

rm(list = c("meta", "metadata", "map", "subjectInfo"))
## % Mitochondrial genes metadata
#mito.genes <- grep(pattern = "^MT-", x = rownames(x = pbmc@data), value = TRUE)
#percent.mito <- Matrix::colSums(pbmc@raw.data[mito.genes, ])/Matrix::colSums(pbmc@raw.data)
#pbmc <- AddMetaData(object = pbmc, metadata = percent.mito, col.name = "percent.mito")
```



## Add Metadata

```{r Subset for Testing, results="asis"}  
metadata <- read.table(file.path(root,"Data/meta.data4.tsv"))
kable(head(metadata), caption = "Metadata") %>%  
  kable_styling(bootstrap_options = kableStyle) %>%
  scroll_box(width = "100%", height = "500px")

# Make AgeGroups
makeAgeGroups <- function(){
  dim(metadata)
  getMaxRound <- function(vals=metadata$Age, unit=10)unit*ceiling((max(vals)/unit))
  getMinRound <- function(vals=metadata$Age, unit=10)unit*floor((min(vals)/unit)) 
   
  ageBreaks = c(seq(getMinRound(), getMaxRound(), by = 10), getMaxRound()+10)
  AgeGroupsUniq <- c()
  for (i in 1:(length(ageBreaks)-1)){ 
    AgeGroupsUniq <- append(AgeGroupsUniq, paste(ageBreaks[i],ageBreaks[i+1], sep="-")) 
  } 
  data.table::setDT(metadata,keep.rownames = T,check.names = F)[, AgeGroups := cut(Age, 
                                  breaks = ageBreaks, 
                                  right = F, 
                                  labels = AgeGroupsUniq,
                                  nclude.lowest=T)]
  metadata <- data.frame(metadata)
  unique(metadata$AgeGroups)
  head(metadata)
  dim(metadata)
  return(metadata)
}
# metadata <- makeAgeGroups()

pbmc <- AddMetaData(object = pbmc, metadata = metadata)  
# Get rid of any NAs (cells that don't match up with the metadata) 
if(subsetCells==F){
  pbmc <- FilterCells(object = pbmc,  subset.names = "nGene", low.thresholds = 0)
} else {pbmc <- FilterCells(object = pbmc,  subset.names = "nGene", low.thresholds = 0,
                    # Subset for testing 
                    cells.use = pbmc@cell.names[0:subsetCells]
                    )
}  
```



## Filter & Normalize Data

### Subset Genes by Biotype

Include only subsets of genes by type.
Biotypes from: https://useast.ensembl.org/info/genome/genebuild/biotypes.html

```{r Subset Genes by Biotype}
subsetBiotypes <- function(pbmc, subsetGenes){
  if( subsetGenes!=F ){
    print(paste("Subsetting genes:",subsetGenes))
    # If the gene_biotypes file exists, import csv. Otherwise, get from biomaRt
    if(file_test("-f", file.path(root,"Data/gene_biotypes.csv"))){
      biotypes <- read.csv(file.path(root,"Data/gene_biotypes.csv"))
    }
    else {
      ensembl <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org",
                       dataset="hsapiens_gene_ensembl") 
      ensembl <- useDataset(mart = ensembl, dataset = "hsapiens_gene_ensembl")
      listFilters(ensembl)
      listAttributes(ensembl)   
      biotypes <- getBM(attributes=c("hgnc_symbol", "gene_biotype"), filters="hgnc_symbol",
            values=row.names(pbmc@data), mart=ensembl) 
      write.csv(biotypes, file.path(root,"Data/gene_biotypes.csv"), quote=F, row.names=F)
    } 
    # Subset data by creating new Seurat object (annoying but necessary)
    geneSubset <- biotypes[biotypes$gene_biotype==subsetGenes,"hgnc_symbol"] 
    
    print(paste(dim(pbmc@raw.data[geneSubset, ])[1],"/", dim(pbmc@raw.data)[1], 
                "genes are", subsetGenes))
    # Add back into pbmc 
    subset.matrix <- pbmc@raw.data[geneSubset, ] # Pull the raw expression matrix from the original Seurat object containing only the genes of interest
    pbmc_sub <- CreateSeuratObject(subset.matrix) # Create a new Seurat object with just the genes of interest
    orig.ident <- row.names(pbmc@meta.data) # Pull the identities from the original Seurat object as a data.frame
    pbmc_sub <- AddMetaData(object = pbmc_sub, metadata = pbmc@meta.data) # Add the idents to the meta.data slot
    pbmc_sub <- SetAllIdent(object = pbmc_sub, id = "ident") # Assign identities for the new Seurat object
    pbmc <- pbmc_sub
    rm(list = c("pbmc_sub","geneSubset", "subset.matrix", "orig.ident")) 
  } 
}

subsetBiotypes(pbmc, subsetGenes)
```

### Subset Cells

Filter by cells, normalize , filter by gene variability.  

```{r Subset Cells }
pbmc <- FilterCells(object = pbmc, subset.names = c("nGene", "percent.mito"), 
    low.thresholds = c(200, -Inf), high.thresholds = c(2500, 0.05))

pbmc <- NormalizeData(object = pbmc, normalization.method = "LogNormalize", 
    scale.factor = 10000)
```

### Subset Genes by Variance

** Important!**: Specify do.par = T, and num.cores = nCores in 'ScaleData' to use all available cores.
```{r Subset Genes by Variance} 
# Store the top most variable genes in @var.genes
pbmc <- FindVariableGenes(object = pbmc, mean.function = ExpMean, dispersion.function = LogVMR,
    x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5)

# IMPORTANT!: Must set do.par=T and num.cors = n for large datasets being processed on computing clusters
pbmc <- ScaleData(object = pbmc, vars.to.regress = c("nUMI", "percent.mito"), do.par = T, num.cores = nCores)
```

### Filtered Dimensions

```{r Filtered Dimensions}
pbmc
```



# Diagnostic Plots

## Violin Plots
```{r Violin Plots }  
vp <- VlnPlot(object = pbmc, features.plot = c("nGene", "nUMI", "percent.mito"),nCol = 3, do.return = T) %>% + ggplot2::aes(alpha=0.5)
vp
```

## Gene Plots {.tabset .tabset-fade .tabset-pills}

### percent.mito plot

```{r percent.mito - process, echo = T, results = 'hide', fig.show='hide'} 
# par(mfrow = c(1, 2))
gp1 <- GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "percent.mito", pch.use=20, 
         do.hover=T, data.hover = "mut")
```

```{r percent.mito - plot} 
gp1
```
 
### nGene plot

```{r nGene - process, echo = T, results = 'hide', fig.show='hide'}
gp2 <- GenePlot(object = pbmc, gene1 = "nUMI", gene2 = "nGene", pch.use=20, 
         do.hover=T, data.hover = "mut")
```

```{r nGene - plot}
gp2
```


# Dimensionality Reduction

## PCA {.tabset .tabset-fade .tabset-pills}

ProjectPCA scores each gene in the dataset (including genes not included
in the PCA) based on their correlation with the calculated components.
Though we don't use this further here, it can be used to identify markers
that are strongly correlated with cellular heterogeneity, but may not have
passed through variable gene selection.  The results of the projected PCA
can be explored by setting use.full=T in the functions above

- Other Dim Reduction Methods in Seurat
  + RunCCA()
  + RunMultiCCA()
  + RunDiffusion()
  + RunPHATE()
  + RunUMAP()
  + RunICA()
  
```{r PCA }
# Run PCA with only the top most variables genes
pbmc <- RunPCA(object = pbmc, pc.genes = pbmc@var.genes, do.print=F) #, pcs.print = 1:5,  genes.print = 5
```

### VizPCA

```{r VizPCA}
VizPCA(object = pbmc, pcs.use = 1:2)
```


### PCA plot

```{r PCAplot} 
PCAPlot(object = pbmc, dim.1 = 1, dim.2 = 2, do.hover=T, data.hover="mut")
```

### PCHeatmaps

```{r PCHeatmap, message=F, warning=F}  
pbmc <- ProjectPCA(object = pbmc, do.print=F) 
# 'PCHeatmap' is a wrapper for heatmap.2 
# PCA Heatmap: PC1-PCn
PCHeatmap(object = pbmc, pc.use = 1:12, do.balanced=T, label.columns=F, use.full=F) 
# 
# PCHeatmap_interactive <- function(PC=1){  
#   PC_dat <- PCHeatmap(object = pbmc, pc.use = PC, do.return = T) 
#   # Cluster samples
#   Xclust <- pcp %>% dist(upper = T) %>% hclust() 
#   Yclust <- PC_dat %>% t() %>% dist(upper = T) %>% hclust() 
#   PC_dat <- PC_dat[Xclust$order, Yclust$order]  
#   # Plotly 
#   plot_ly(y=row.names(PC_dat), z=matrix(PC_dat), type = "heatmap", 
#           colors =viridis::plasma(n=100))
# }
# PCHeatmap_interactive(PC=1)   
 
```


### Significant PCs

Determine statistically significant PCs for further analysis.
NOTE: This process can take a long time for big datasets, comment out for
expediency.  More approximate techniques such as those implemented in
PCElbowPlot() can be used to reduce computation time

```{r Significant PCs }
#pbmc <- JackStraw(object = pbmc, num.replicate = 100, display.progress = FALSE)
PCElbowPlot(object = pbmc)
```

## Find Cell Clusters
We first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). To cluster the cells, we apply modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function.

**On Resolution**  
The FindClusters function implements the procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.6-1.2 typically returns good results for single cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters are saved in the object@ident slot.
```{r Cluster cells } 
# TRY DIFFERENT RESOLUTIONS
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10, resolution = resolution, print.output = 0, save.SNN = T) 
PrintFindClustersParams(object = pbmc) 
```


## t-SNE
As input to the tSNE, we suggest using the same PCs as input to the clustering analysis, although computing the tSNE based on scaled gene expression is also supported using the genes.use argument.  

** Important!**: Specify num_threads=0 in 'RunTSNE' to use all available cores.
```{r t-SNE } 
labSize <- 6
#pbmc <- StashIdent(object = pbmc, save.name = "pre_clustering") 
#pbmc <- SetAllIdent(object = pbmc, id = "pre_clustering") 

pbmc <- RunTSNE(object=pbmc,  reduction.use = "pca", dims.use = 1:10, do.fast = TRUE, 
                tsne.method = "Rtsne", num_threads=0) # num_threads
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = pbmc, do.label=T, label.size = labSize, do.return=T) %>% ggplotly() 
```


## t-SNE + Metadata Plots {.tabset .tabset-fade .tabset-pills}

```{r t-SNE + Metadata, warning=F, message=F}
tSNE_metadata_plot <- function(var){
  print(paste("t-SNE Metadata plot for ", var))
  # Metadata plot 
  p1 <- TSNEPlot(pbmc, do.return = T,  do.label = T,  group.by = var, pt.size=1,
                 plot.title=paste("Color by ",var), vector.friendly=T) %>% ggplotly() %>% 
     layout(legend = list(orientation = 'h', xanchor = "center", x = 0.5, y = .999)) 
  # t-SNE clusters plot
  p2 <- TSNEPlot(pbmc, do.return = T, do.label = T, pt.size=1,
                 plot.title=paste("Color by Clusters"), vector.friendly=T) %>% ggplotly() %>% 
  layout(legend = list(orientation = 'h', xanchor = "center", x = 0.5, y = .999)) 
  #print(plot_grid(ggplotly(p1), ggplotly(p2)))
  fluidPage( 
    fluidRow(
      column(6, p1), column(6, p2) 
    )
  )
}   
# metaVars <- c(dx","mut","Gender","Age")
# 
# for (var in metaVars){
#   print(paste("t-SNE Metadata plot for ",var))
#   # Metadata plot 
#   p1 <- TSNEPlot(pbmc, do.return = T, pt.size = 0.5, group.by = var, do.label = T, 
#                  dark.theme=F, plot.title=paste("Color by ",var))
#   # t-SNE clusters plot
#   p2 <- TSNEPlot(pbmc, do.label = T, do.return = T, pt.size = 0.5, plot.title=paste("Color by t-SNE clusters"))
#   print(plot_grid(p1, p2))
# }   

```


### Disease

```{r dx}
tSNE_metadata_plot("dx") 
```

### Mutations

```{r mut, fig.width = 12}
tSNE_metadata_plot("mut") 
```

### Gender

```{r Gender, fig.width = 12}
tSNE_metadata_plot("Gender") 
```

### Age

```{r Age, fig.width = 12}
tSNE_metadata_plot("Age") 
```


# Cluster Biomarkers

Seurat has several tests for differential expression which can be set with the test.use parameter (see the DE vignette for details). For example, the ROC test returns the ‘classification power’ for any individual marker (ranging from 0 - random, to 1 - perfect).

```{r cluster biomarkers tests, results="asis"}  
### Biomarkers: All Clusters vs. All Other Clusters ***
# find markers for every cluster compared to all remaining cells, report
# only the positive ones
pbmc.markers <- FindAllMarkers(object = pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
topBiomarkers <- pbmc.markers %>% group_by(cluster) %>% top_n(2, avg_logFC)
 
kable(topBiomarkers) %>% kable_styling(bootstrap_options = kableStyle) 
```

## Cluster Biomarker Tests {.tabset .tabset-fade .tabset-pills}

```{r cluster biomarker plots, results='asis'}

getTopBiomarker <- function(pbmc.markers, clusterID, topN=1){
  df <- subset(pbmc.markers, p_val_adj<0.05 & cluster==as.character(clusterID)) %>% arrange(desc(avg_logFC))
  top_pct_markers <- df[1:topN,"gene"]
  return(top_pct_markers)
}
# clust1_biomarkers <- getTopBiomarker(pbmc.markers, clusterID=1, topN=2)
# clust2_biomarkers <- getTopBiomarker(pbmc.markers, clusterID=2, topN=2)


### Plot biomarkers 
plotBiomarkers <- function(pbmc, biomarkers, cluster){
  biomarkerPlots <- list()
  for (marker in biomarkers){ 
    p <- VlnPlot(object = pbmc, features.plot = c(marker), y.log=T, return.plotlist=T) 
    biomarkerPlots[[marker]] <- p + ggplot2::aes(alpha=0.5) + xlab( "Cluster") + ylab( "Expression")
  }
  combinedPlot <- do.call(grid.arrange, c(biomarkerPlots, list(ncol=2, top=paste("Top DEG Biomarkers for Cluster",cluster))) ) 

  # biomarkerPlots <- lapply(biomarkers, function(marker) {
  #   VlnPlot(object = pbmc, features.plot = c(marker), y.log=T, return.plotlist=T) %>% + ggplot2::ggtitle(marker) %>% ggplotly() 
  # })    
  # return(subplot(biomarkerPlots) )
}   

top1 <- pbmc.markers %>% group_by(cluster) %>% top_n(1, avg_logFC) 
nCols <- floor( sqrt(length(unique(top1$cluster))) )   
figHeight <- nCols *7

# Plot top 2 biomarker genes for each 
for (clust in unique(pbmc.markers$cluster)){ 
   cat('\n')   
   cat("### Cluster ",clust,"\n") 
   biomarkers <- getTopBiomarker(pbmc.markers, clusterID=clust, topN=2)
   plotBiomarkers(pbmc, biomarkers, clust)  
   cat('\n')   
} 
```
 


## Top Biomarker Plot

###  Biomarkers tSNE

```{r Biomarkers tSNE} 
fp <- FeaturePlot(object = pbmc, features.plot = top1$gene, cols.use = c("grey", "purple"), 
    reduction.use = "tsne", nCol = nCols, do.return = T) 
```


### Biomarkers Heatmap

```{r Biomarkers Heatmap }
top5 <- pbmc.markers %>% group_by(cluster) %>% top_n(5, avg_logFC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of
# every cell name
DoHeatmap(object = pbmc, genes.use = top5$gene, slim.col.label=T, remove.key=T) %>% ggplotly()
```

### Biomarkers Ridgeplot

```{r Biomarkers RidgePlot}
RidgePlot(pbmc, features.plot = top1$gene,  nCol = nCols, do.sort = F)
```


# Map Clusters to Known Biomarkers

- Known Monocytes Biomarkers
 + Classical: CD14++ / CD16--
 + Intermediate: CD14++ / CD16+
 + Nonclassical: CD14+ / CD16++ (not captured in this data)
  

```{r Map Clusters}
markerList <- c("CD14", "FCGR3A") 

genes_by_cluster <- function(pbmc, markerList){
  marker.matrix <- pbmc@scale.data[row.names(pbmc@scale.data) %in% markerList, ]   
  markerMelt <- reshape2:::melt.matrix(marker.matrix)
  colnames(markerMelt) <- c("Gene", "Cell", "Expression")
  identData <- data.frame(pbmc@ident)  
  identData$Cell <- row.names(identData)
  colnames(identData) <- c("Cluster","Cell") 
  markerDF <- merge(markerMelt,  identData, by = "Cell")
 
  return(markerDF)
}
markerDF <- genes_by_cluster(pbmc, markerList)
```

## Known Biomarkers: Heatmaps

### Clusters Averaged

```{r Clusters Averaged}
# Show mean exp for each marker
avgMarker <- markerDF %>% group_by(Gene, Cluster) %>% summarise(meanExp = mean(Expression)) 
ggplot(data = avgMarker, aes(x=Gene, y=Cluster, fill=meanExp)) %>% + geom_tile() %>% + scale_fill_distiller(palette="viridis") %>% ggplotly()
```

### Clusters Separated

```{r Clusters Separated}
markerMelt <- reshape2::acast(markerDF, Cell~Gene, value.var="Expression", fun.aggregate = mean, drop = F, fill = 0) 

#plot_ly(  z = markerMelt, y=row.names(markerMelt), z=colnames(markerMelt), type="heatmap")
# dx_colors <- colorRampPalette(brewer.pal(2, "RdBu"))
# mut_colors <- colorRampPalette(brewer.pal(length(unique(pbmc@meta.data$mut)), "Set3"))
Spectral <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(length(unique(pbmc@meta.data$mut)), "Spectral"))
# Spectral <- heatmaply::Spectral(length(unique(pbmc@meta.data$mut)))

heatmaply::heatmaply(markerMelt,  key.title="Expression",#plot_method= "plotly",
          k_row = length(unique(pbmc.markers)), dendrogram = "row",
          showticklabels = c(T, F), xlab = "Known Markers", ylab = "Cells", column_text_angle = 0,
          row_side_colors =  pbmc@meta.data[,c("dx","mut")], row_side_palette = Spectral
          )  %>%  colorbar(tickfont = list(size = 12), titlefont = list(size = 14), which = 2)  %>% 
          colorbar(tickfont = list(size = 12), titlefont = list(size = 14), which = 1) 
```


## Known Biomarkers: Boxplot

```{r Known Biomarkers: Boxplot} 
ggplot(data = markerDF, aes(x=Cluster, y=Expression, fill=Gene)) %>% 
  + geom_boxplot(alpha=0.5) %>% + scale_fill_manual(values=c("purple", "turquoise")) # %>% ggplotly()  
```



##  Known Biomarkers: tSNE

```{r Known Biomarkers: tSNE }
expressionTSNE <- function(pbmc, marker, colors=c("grey", "red")){
  FeaturePlot(object = pbmc, features.plot = marker, cols.use = colors, 
    reduction.use = "tsne", nCol=2, do.return = T, dark.theme = T)[[1]] %>% ggplotly()
}
 
 subplot(expressionTSNE(pbmc, markerList[1]), 
        expressionTSNE(pbmc, markerList[2],  colors=c("grey", "green")))
```


## Label Clusters by Known Biomarker 
```{r Label Clusters by Biomarker }
current.cluster.ids <- unique(pbmc.markers$cluster) #c(0, 1, 2, 3, 4, 5, 6, 7)
top1 <- pbmc.markers %>% group_by(cluster) %>% top_n(1, avg_logFC)
new.cluster.ids <- top1$gene #c("CD4 T cells", "CD14+ Monocytes", "B cells", "CD8 T cells", "FCGR3A+ Monocytes", "NK cells", "Dendritic cells", "Megakaryocytes")

pbmc@ident <- plyr::mapvalues(x = pbmc@ident, from = current.cluster.ids, to = new.cluster.ids)
TSNEPlot(object=pbmc, do.label=T, pt.size=0.5, do.return=T) %>% ggplotly()
```

# Cell Sub-clusters {.tabset .tabset-fade .tabset-pills}

Further subdivisions within cell types.  
If you perturb some of our parameter choices above (for example, setting resolution=0.8 or changing the number of PCs), you might see the CD4 T cells subdivide into two groups. You can explore this subdivision to find markers separating the two T cell subsets. However, before reclustering (which will overwrite object@ident), we can stash our renamed identities to be easily recovered later.

## Assign Identity
```{r Assign Identity, fig.width=12}
# First lets stash our identities for later
pbmc <- StashIdent(object = pbmc, save.name = "ClusterNames_0.6")

# Note that if you set save.snn=T above, you don't need to recalculate the
# SNN, and can simply put: pbmc <- FindClusters(pbmc,resolution = 0.8)
pbmc <- FindClusters(object = pbmc, reduction.type = "pca", dims.use = 1:10, 
    resolution = 0.8, print.output = FALSE)

## Warning in BuildSNN(object = object, genes.use = genes.use, reduction.type
## = reduction.type, : Build parameters exactly match those of already
## computed and stored SNN. To force recalculation, set force.recalc to TRUE.

# Demonstration of how to plot two tSNE plots side by side, and how to color
# points based on different criteria
plot1 <- TSNEPlot(object = pbmc, do.return = TRUE, no.legend = TRUE, do.label = TRUE, label.size=labSize)
plot2 <- TSNEPlot(object = pbmc, do.return = TRUE, group.by = "ClusterNames_0.6", 
                  no.legend = TRUE, do.label = TRUE, label.size=labSize)
plot_grid(plot1, plot2)
```

## Find Markers

```{r Find Markers}
# Find discriminating markers
tcell.markers <- FindMarkers(object = pbmc, ident.1 = 0, ident.2 = 1)

# Most of the markers tend to be expressed in C1 (i.e. S100A4). However, we
# can see that CCR7 is upregulated in C0, strongly indicating that we can
# differentiate memory from naive CD4 cells.  cols.use demarcates the color
# palette from low to high expression
FeaturePlot(object = pbmc, features.plot = top1$gene, cols.use = c("green", "blue"))

pbmc <- SetAllIdent(object = pbmc, id = "ClusterNames_0.6") 
```


```{r Save Results} 
# Save results for EACH run (in their respective subfolders)
saveRDS(pbmc, file=file.path(params$resultsPath, "cd14-processed.rds") )
```


