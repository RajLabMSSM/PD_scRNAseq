---
title: "PD_scRNAseq: Monocle3" 
author: "<h3>Author</h3>Brian M. Schilder, Bioinformatician II"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_document: 
    theme: spacelab
    highlight: zenburn 
    code_folding: show 
    toc: true 
    toc_float: true
    smooth_scroll: true
    number_sections: false 
    self_contained: true
params:
  subsetGenes: "protein_coding" #FALSE
  subsetCells: 500 #FALSE
  resolution: 0.6
  resultsPath: "./Results"
  nCores: 2
  perplexity: 30
editor_options: 
  chunk_output_type: inline
---

# Setup 

```{r setup, dpi = 600, warning=F, message=F}
start_time <- Sys.time() 

#### #### Load Objects & Functions #### #### 
######################################################
# Import functions
root = "./"
source(file.path(root,"MAIN.R"))
import_parameters(params)
# load("Results/Current_Pipeline/scRNAseq_results.RData")
load(file.path(resultsPath, "scRNAseq_results.RData")) 
######################################################


#### #### PACKAGES #### #### 
######################################################
print("Written using: Seurat version* 2.3.4 2018-07-17")
# https://satijalab.org/seurat/install.html
library(Seurat) #
paste("Seurat", packageVersion("Seurat")) 
# library(monocle) # BiocManager::install("monocle")   
# paste("monocle", packageVersion("monocle")) 
library(monocle3)
paste("monocle3", packageVersion("monocle3")) 
library(garnett) # devtools::install_github("cole-trapnell-lab/garnett")
paste("garnett", packageVersion("garnett"))
 
library(cowplot) 
library(ggplot2)
library(dplyr) 
library(data.table) 
library(readxl) 
library(reshape2)
library(ggrepel)
library(plotly)
library(GeneOverlap) # BiocManager::install("GeneOverlap") 
######################################################


# Exporting 3D plots 
knitr::knit_hooks$set(webgl = rgl::hook_webgl)
dge_limit <- F # 100
nCores <- 4#parallel::detectCores()
set.seed(2019)
```

# Preprocessing

## Seurat/2.3.4 to Monocle3

Also subset to only protein-coding genes.

```{r Seurat/2.3.4 to Monocle3}
biotypes <- get_biotypes(DAT)
proteins <- biotypes[biotypes$gene_biotype=="protein_coding",]$hgnc_symbol %>% droplevels()
protDAT <- subset_seurat(DAT, genes.use = proteins)

cds <- seurat_to_monocle(seurat_object = DAT, monocle_version = 3)
cds <- cds[levels(proteins),]
```
 
## Normalization & PCA

```{r Normalize Data}    
cds <- monocle3::preprocess_cds(cds, 
                                num_dim = 20, #100 by default
                                residual_model_formula_str = "~ nUMI + percent.mito")
monocle3::plot_pc_variance_explained(cds) 
```


## Dimensionality Reduction

Using UMAP.

```{r Dimensionality Reduction}
# c("UMAP", "tSNE", "PCA", "LSI")
cds <- monocle3::reduce_dimension(cds, reduction_method = "UMAP", 
                                  max_components = 3
                                  # umap.fast_sgd = T,
                                  # cores=nCores
                                  ) 
```


# Clustering

- Unsupervised clustering of cells is a common step in many single-cell expression workflows. In an experiment containing a mixture of cell types, each cluster might correspond to a different cell type. - This function takes a cell_data_set as input, clusters the cells using Louvain community detection, and returns a cell_data_set with internally stored cluster assignments. 
- In addition to clusters this function calculates partitions, which represent superclusters of the Louvain communities that are found using a kNN pruning method. Cluster assignments can be accessed using the clusters function and partition assignments can be accessed using the partitions function.

- Using only the topN variable genes to cluster

## Find Variable Genes

```{r Find Variable Genes} 
# Method 1
# variable.genes <- cds@preprocess_aux@listData$gene_loadings[,1:3] %>%
#   abs() %>% rowSums() %>% base::sort(decreasing = T)
# head(variable.genes) 
varDAT <- Seurat::FindVariableGenes(object = protDAT, 
                             mean.function = ExpMean, 
                             dispersion.function = LogVMR, 
                             selection.method ="dispersion", do.plot = T, 
                             top.genes = 2000)
var.genes <- varDAT@var.genes
head(var.genes)
```

## Louvain Clustering

```{r Louvain Clustering, webgl=TRUE}
cds <- monocle3::cluster_cells(cds,
                               resolution = 1e-4,#c(10^seq(-6,-1)), # Do NOT set to high number 
                               reduction_method = "UMAP", 
                               cores = nCores,
                               clustering_genes = var.genes)
# Add cluster info to metadata (for easier DGE analysis)
pData(cds)$Cluster <- monocle3::clusters(cds)
pData(cds)$Partition <- monocle3::partitions(cds)
# 3D plot
p3d <- plot_cells_3d(cds, color_cells_by = "cluster", show_trajectory_graph = F)
p3d

# Save each cluster as a separate OBJ file that can later be 
# imported into a 3D modeling platform (e.g. Blender, Meshlab) for more advanced visualization
## save_3D_clusters(cds)
```


# Pseudotime

```{r Pseudotime} 
# Learn
cds <- monocle3::learn_graph(cds)
# Order cells
root_pr_nodes = get_earliest_principal_node(cds, variable = "dx", variable_value = "PD")
cds <- monocle3::order_cells(cds, root_pr_nodes = root_pr_nodes) 

monocle3::plot_cells(cds)
monocle3::plot_genes_in_pseudotime(cds[c("CD14","FCGR3A"), ] )
```

### UMAP Plots {.tabset .tabset-fade .tabset-pills}

Disease status (dx), mutation status (mut), and individual ID (ID) show good mixture across clusters.

```{r UMAP Plots, results="asis"}
for(v in c("dx","mut","ID")){
  cat("\n")
  cat("####",v,"\n")
  p <- monocle3::plot_cells(cds, color_cells_by=v, label_cell_groups=F, show_trajectory_graph = F)
  print(p)
  cat("\n")
} 
```


# Cell-type Identication

## Garnett

Use a pre-trained classifier from Pline et al.

```{r Garnett}
library(org.Hs.eg.db)
columns(org.Hs.eg.db)

# load(url("https://cole-trapnell-lab.github.io/garnett/classifiers/hsPBMC")) 
load("./Data/Garnett/hsPBMC")
cds = garnett::classify_cells(cds, 
                               hsPBMC,
                               db = org.Hs.eg.db,
                               cluster_extend = T,
                               cds_gene_id_type = "SYMBOL")
monocle3::plot_cells(cds,
                     group_cells_by="cluster",
                     color_cells_by="cluster_ext_type",  # cell_type
                     show_trajectory_graph = F )
```


## Gene Expression Plots

```{r Gene Expression Plots}
# Violin
monocle3::plot_genes_violin(cds[c("CD14","FCGR3A"),], group_cells_by = "dx")

# UMAP 
monocle3::plot_cells(cds, 
                     genes=c("CD14","FCGR3A"), 
                     group_cells_by = "cluster",
                     show_trajectory_graph = F)
monocle3::plot_cells(cds, 
                     genes=unique(top_specific_markers$gene_id), 
                     group_cells_by = "cluster",
                     show_trajectory_graph = F)
# monocle3::plot_cells_3d(cds, genes="FCGR3A", show_trajectory_graph = F)
```



# Graph-autocorrelation Analysis 

Find genes of interest through graph-autocorrelation analysis.

```{r Graph-autocorrelation Analysis}
# pr_graph_test_res = monocle3::graph_test(cds, neighbor_graph="knn", cores=nCores)
# pr_deg_ids = row.names(subset(pr_graph_test_res, q_value < 0.05))
```

# Gene Modules

- Identify co-expression modules.<br>
`find_gene_modules` essentially runs UMAP on the genes (as opposed to the cells) and then groups them into modules using Louvain community analysis.
- **Advantages**: Much faster than other alogrithms like WGCNA.  
- **Disadvantages**: Seems to be limited of ~1000 genes.

```{r Gene Modules}
gene_module_df = monocle3::find_gene_modules(cds_DGE[var.genes[1:1000], ], 
                                             resolution=1e-2, 
                                             max_components = 3,
                                             cores=nCores)
# Create pheatmap table
cell_group_df = tibble::tibble(cell=row.names(colData(cds)),
                               cell_group=clusters(cds)[colnames(cds)])
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) = stringr::str_c("Cluster ", colnames(agg_mat))

pheatmap::pheatmap(agg_mat, cluster_rows=TRUE, cluster_cols=TRUE,
                   scale="column", clustering_method="ward.D2",
                   fontsize=6)
# rgl::plot3d(x = gene_module_df$dim_1, y=gene_module_df$dim_2, z=gene_module_df$dim_3)
```

## Module Expression

```{r Module Expression}
monocle3::plot_cells(cds,
                     genes=gene_module_df,
                     group_cells_by="cluster",
                     color_cells_by="cluster",
                     show_trajectory_graph=F) #  rasterize = T (for super high-res figures)
```



# Save Checkpoint

Save R object and run memory-intensive DGE analyses on computing cluster.

```{r Save Checkpoint}
# saveRDS(cds, file="./Data/monocle3_CDS.RData")
save(cds, var.genes, file = "./Data/monocle3_CDS.RData")

```

